<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maoyunfei.github.io/"/>
  <updated>2018-03-04T09:38:51.314Z</updated>
  <id>https://maoyunfei.github.io/</id>
  
  <author>
    <name>云逸云飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 8新特性之Date/Time API</title>
    <link href="https://maoyunfei.github.io/java/7dd3efa4/"/>
    <id>https://maoyunfei.github.io/java/7dd3efa4/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.314Z</updated>
    
    <content type="html"><![CDATA[<p>在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是<code>java.util</code>和<code>java.sql</code>中，都包含<code>Date</code>类，如果要处理由<code>java.text.DateFormat</code>类处理。同时<code>java.util.Date</code>中既包含了日期，又包含了时间，所以java 8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方库<code>joda</code>很多的优点。</p><h2 id="对比旧的日期API"><a href="#对比旧的日期API" class="headerlink" title="对比旧的日期API"></a>对比旧的日期API</h2><table><thead><tr><th>Java.time</th><th>java.util.Calendar以及Date</th></tr></thead><tbody><tr><td>流畅的API</td><td>不流畅的API</td></tr><tr><td>实例不可变</td><td>实例可变</td></tr><tr><td>线程安全</td><td>非线程安全</td></tr></tbody></table><a id="more"></a><h2 id="新API介绍"><a href="#新API介绍" class="headerlink" title="新API介绍"></a>新API介绍</h2><h3 id="1、主要的类"><a href="#1、主要的类" class="headerlink" title="1、主要的类:"></a>1、主要的类:</h3><p><strong><code>java.time</code>包下的类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Instant：时间戳  </span><br><span class="line">Duration：持续时间，时间差  </span><br><span class="line">LocalDate：只包含日期，比如：2016-10-20  </span><br><span class="line">LocalTime：只包含时间，比如：23:12:10  </span><br><span class="line">LocalDateTime：包含日期和时间，比如：2016-10-20 23:14:21  </span><br><span class="line">Period：时间段  </span><br><span class="line">ZoneOffset：时区偏移量，比如：+8:00  </span><br><span class="line">ZonedDateTime：带时区的时间  </span><br><span class="line">Clock：时钟，比如获取目前美国纽约的时间</span><br></pre></td></tr></table></figure><p><strong>以及<code>java.time.format</code>包下的类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter：时间格式化</span><br></pre></td></tr></table></figure><h3 id="2、主要的类的值的格式"><a href="#2、主要的类的值的格式" class="headerlink" title="2、主要的类的值的格式:"></a>2、主要的类的值的格式:</h3><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/date_time_api.jpg?raw=true" width="60%" height="60%" align="center"></p><h3 id="3、通过例子来看如何使用java8新的日期时间库"><a href="#3、通过例子来看如何使用java8新的日期时间库" class="headerlink" title="3、通过例子来看如何使用java8新的日期时间库"></a>3、通过例子来看如何使用java8新的日期时间库</h3><h4 id="1-获取今天的日期"><a href="#1-获取今天的日期" class="headerlink" title="(1) 获取今天的日期"></a>(1) 获取今天的日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate todayDate = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"今天的日期："</span>+todayDate);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">今天的日期：<span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="2-指定日期，进行相应操作"><a href="#2-指定日期，进行相应操作" class="headerlink" title="(2) 指定日期，进行相应操作"></a>(2) 指定日期，进行相应操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取2016年10月的第1天</span></span><br><span class="line">LocalDate firstDay = oneday.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">System.out.println(firstDay);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//取2016年10月的第1天，另外一种写法</span></span><br><span class="line">LocalDate firstDay2 = oneday.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">System.out.println(firstDay2);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//取2016年10月的最后1天，不用考虑大月，小月，平年，闰年</span></span><br><span class="line">LocalDate lastDay = oneday.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(lastDay);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//当前日期＋1天</span></span><br><span class="line">LocalDate tomorrow = oneday.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为闰年</span></span><br><span class="line"><span class="keyword">boolean</span> isLeapYear = tomorrow.isLeapYear();</span><br><span class="line">System.out.println(isLeapYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">21</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="3-生日检查或者账单日检查"><a href="#3-生日检查或者账单日检查" class="headerlink" title="(3) 生日检查或者账单日检查"></a>(3) 生日检查或者账单日检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开发过程中，经常需要为过生日的用户送上一些祝福，例如，用户的生日为<span class="number">1990</span>-<span class="number">10</span>-<span class="number">12</span>，如果今天是<span class="number">2016</span>-<span class="number">10</span>-<span class="number">12</span>，那么今天就是用户的</span><br><span class="line"></span><br><span class="line">生日(按公历/身份证日期来算)，那么通过java8新的日期库，我们该如何来进行判断？</span><br><span class="line"></span><br><span class="line">在java <span class="number">8</span>中，可以使用MonthDay，该类不包含年份信息，当然还有一个类是YearMonth</span><br><span class="line"></span><br><span class="line">LocalDate birthday = LocalDate.of(<span class="number">1990</span>, <span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.of(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">12</span>)); </span><br><span class="line">System.out.println(today.equals(birthdayMd));</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="4-获取当前的时间"><a href="#4-获取当前的时间" class="headerlink" title="(4) 获取当前的时间"></a>(4) 获取当前的时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">时间主要是使用LocalTime，该类不包含日期，只有时间信息</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的时间</span></span><br><span class="line">LocalTime nowTime = LocalTime.now(); <span class="comment">//结果14:29:40.558</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//如果不想显示毫秒</span></span><br><span class="line">LocalTime nowTime2 = LocalTime.now().withNano(<span class="number">0</span>); <span class="comment">//14:43:14</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//指定时间</span></span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">14</span>, <span class="number">10</span>, <span class="number">21</span>); <span class="comment">//14:10:21</span></span><br><span class="line">LocalTime time2 = LocalTime.parse(<span class="string">"12:00:01"</span>); <span class="comment">// 12:00:01</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//当前时间增加2小时</span></span><br><span class="line">LocalTime nowTimePlus2Hour = nowTime.plusHours(<span class="number">2</span>); <span class="comment">//16:47:23.144</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LocalTime nowTimePlus2Hour2 = nowTime.plus(<span class="number">2</span>, ChronoUnit.HOURS);</span><br></pre></td></tr></table></figure><h4 id="5-日期前后比较"><a href="#5-日期前后比较" class="headerlink" title="(5) 日期前后比较"></a>(5) 日期前后比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比较<span class="number">2</span>个日期哪个在前，哪个在后，java8 LocalDate提供了<span class="number">2</span>个方法，isAfter(),isBefore</span><br><span class="line"></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate specifyDate = LocalDate.of(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(today.isAfter(specifyDate)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="6-处理不同时区的时间"><a href="#6-处理不同时区的时间" class="headerlink" title="(6) 处理不同时区的时间"></a>(6) 处理不同时区的时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java8中，将日期、时间，时区都很好的进行了分离。</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当前的时区</span></span><br><span class="line">ZoneId defaultZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(defaultZone); <span class="comment">//Asia/Shanghai</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//查看美国纽约当前的时间</span></span><br><span class="line">ZoneId america = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">LocalDateTime shanghaiTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime americaDateTime = LocalDateTime.now(america);</span><br><span class="line">System.out.println(shanghaiTime); <span class="comment">//2016-11-06T15:20:27.996</span></span><br><span class="line">System.out.println(americaDateTime); <span class="comment">//2016-11-06T02:20:27.996 ，可以看到美国与北京时间差了13小时</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//带有时区的时间</span></span><br><span class="line">ZonedDateTime americaZoneDateTime = ZonedDateTime.now(america);</span><br><span class="line">System.out.println(americaZoneDateTime); <span class="comment">//2016-11-06T02:23:44.863-05:00[America/New_York]</span></span><br></pre></td></tr></table></figure><h4 id="7-比较两个日期之前时间差"><a href="#7-比较两个日期之前时间差" class="headerlink" title="(7) 比较两个日期之前时间差"></a>(7) 比较两个日期之前时间差</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在项目中，经常需要比较两个日期之间相差几天，或者相隔几个月，我们可以使用java8的Period来进行处理。</span><br><span class="line"></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate specifyDate = LocalDate.of(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">Period period = Period.between(specifyDate, today);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getDays());  <span class="comment">//4</span></span><br><span class="line">System.out.println(period.getMonths()); <span class="comment">//1</span></span><br><span class="line">System.out.println(specifyDate.until(today, ChronoUnit.DAYS)); <span class="comment">//401</span></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">401</span></span><br><span class="line">我们可以看到，我们使用Period类比较天数，但它返回的值，并不是<span class="number">2</span>个日期之间总共的天数差，而是一个相对天数差，比如<span class="number">5</span>月<span class="number">1</span>日和</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>月<span class="number">2</span>日，他比较的是仅仅<span class="number">2</span>个天之间的差，那<span class="number">1</span>号和<span class="number">2</span>号，相差<span class="number">1</span>天，而实际上，因为中间相差了好几个月，所以真正的天数差肯定不是<span class="number">1</span>天，</span><br><span class="line"></span><br><span class="line">所以我们可以使用until，并指明精度单位是days，就可以计算真正的天数差了。</span><br></pre></td></tr></table></figure><h4 id="8-日期时间格式解析、格式化"><a href="#8-日期时间格式解析、格式化" class="headerlink" title="(8) 日期时间格式解析、格式化"></a>(8) 日期时间格式解析、格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在java8之前，我们进行时间格式化主要是使用SimpleDateFormat，而在java8中，主要是使用DateTimeFormatter，java8中，预定</span><br><span class="line"></span><br><span class="line">义了一些标准的时间格式，我们可以直接将时间转换为标准的时间格式：</span><br><span class="line"></span><br><span class="line">String specifyDate = <span class="string">"20151011"</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;</span><br><span class="line">LocalDate formatted = LocalDate.parse(specifyDate,formatter); </span><br><span class="line">System.out.println(formatted); </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">10</span>-<span class="number">11</span></span><br><span class="line">当然，很多时间标准的时间格式可能也不满足我们的要求，我们需要转为自定义的时间格式</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">"YYYY MM dd"</span>);</span><br><span class="line">System.out.println(formatter2.format(LocalDate.now()));</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">2015</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="9-java8-时间类与Date类的相互转化"><a href="#9-java8-时间类与Date类的相互转化" class="headerlink" title="(9) java8 时间类与Date类的相互转化"></a>(9) java8 时间类与Date类的相互转化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在转换中，我们需要注意，因为java8之前Date是包含日期和时间的，而LocalDate只包含日期，LocalTime只包含时间，所以与Date在</span><br><span class="line"></span><br><span class="line">互转中，势必会丢失日期或者时间，或者会使用起始时间。如果转LocalDateTime，那么就不存在信息误差。</span><br><span class="line"></span><br><span class="line"><span class="comment">//Date与Instant的相互转化</span></span><br><span class="line">Instant instant  = Instant.now();</span><br><span class="line">Date date = Date.from(instant);</span><br><span class="line">Instant instant2 = date.toInstant();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//Date转为LocalDateTime</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.ofInstant(date2.toInstant(), ZoneId.systemDefault());</span><br><span class="line">        </span><br><span class="line"><span class="comment">//LocalDateTime转Date</span></span><br><span class="line">LocalDateTime localDateTime3 = LocalDateTime.now();</span><br><span class="line">Instant instant3 = localDateTime3.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date3 = Date.from(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDate转Date</span></span><br><span class="line"><span class="comment">//因为LocalDate不包含时间，所以转Date时，会默认转为当天的起始时间，00:00:00</span></span><br><span class="line">LocalDate localDate4 = LocalDate.now();</span><br><span class="line">Instant instant4 = localDate4.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date4 = Date.from(instant);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是&lt;code&gt;java.util&lt;/code&gt;和&lt;code&gt;java.sql&lt;/code&gt;中，都包含&lt;code&gt;Date&lt;/code&gt;类，如果要处理由&lt;code&gt;java.text.DateFormat&lt;/code&gt;类处理。同时&lt;code&gt;java.util.Date&lt;/code&gt;中既包含了日期，又包含了时间，所以java 8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方库&lt;code&gt;joda&lt;/code&gt;很多的优点。&lt;/p&gt;&lt;h2 id=&quot;对比旧的日期API&quot;&gt;&lt;a href=&quot;#对比旧的日期API&quot; class=&quot;headerlink&quot; title=&quot;对比旧的日期API&quot;&gt;&lt;/a&gt;对比旧的日期API&lt;/h2&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Java.time&lt;/th&gt;&lt;th&gt;java.util.Calendar以及Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;流畅的API&lt;/td&gt;&lt;td&gt;不流畅的API&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实例不可变&lt;/td&gt;&lt;td&gt;实例可变&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;线程安全&lt;/td&gt;&lt;td&gt;非线程安全&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java 8" scheme="https://maoyunfei.github.io/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性之函数式接口和Lambda表达式</title>
    <link href="https://maoyunfei.github.io/java/c8f73c32/"/>
    <id>https://maoyunfei.github.io/java/c8f73c32/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.334Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象并不坏，但它给程序带来了很多冗长的内容。例如，假设我们要创建一个Runnable的实例。通常我们使用下面的匿名类来完成它：<br><a id="more"></a><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"My Runnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p></p><p>如果你看看上面的代码，实际使用的部分是 run() 方法中的代码。其余所有的代码是因为Java程序的结构化方式。</p><p>Java 8函数式接口和Lambda表达式通过删除大量的样板代码，帮助我们编写更少、更简洁的代码。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>具有一个抽象方法的接口称为函数式接口。添加了<code>@FunctionalInterface</code>注解，以便我们可以将接口标记为函数式接口。</p><p>使用它不是强制性的，但最好的做法是将它与函数式接口一起使用，以避免意外添加额外的方法。如果接口使用<code>@FunctionalInterface</code>注解进行注释，并且我们尝试使用多个抽象方法，则会引发编译器错误。</p><p><strong>Java 8函数式接口的主要好处是我们可以使用lambda表达式来实例化它们，避免使用笨重的匿名类实现。</strong></p><p>Java 8 Collections API已被重写，并引入了新的Stream API，它使用了许多函数式接口。 Java 8在<code>java.util.function</code>包中定义了很多函数式接口。一些有用的java 8函数式接口如<code>Consumer</code>、<code>Supplier</code>、<code>Function</code>和<code>Predicate</code>。</p><p><code>java.lang.Runnable</code>是使用单一抽象方法 run() 的函数式接口的一个很好的例子。</p><h3 id="下面的代码片段为函数式接口提供了一些指导："><a href="#下面的代码片段为函数式接口提供了一些指导：" class="headerlink" title="下面的代码片段为函数式接口提供了一些指导："></a>下面的代码片段为函数式接口提供了一些指导：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>; &#125;</span><br><span class="line"><span class="comment">// Not functional because equals is already an implicit member (Object class)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Functional because Comparator has only one abstract non-Object method</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Not functional because method Object.clone is not public</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Functional: two methods, but they have the same signature</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function">Iterable <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function">Iterable&lt;String&gt; <span class="title">m</span><span class="params">(Iterable arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Functional: Y.m is a subsignature &amp; return-type-substitutable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;Integer&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Not functional: No method has a subsignature of all abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg, Class c)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable arg, Class&lt;?&gt; c)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Not functional: No method has a subsignature of all abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">m</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Compiler error: no method is return type substitutable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(T arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bar</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(T arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooBar</span>&lt;<span class="title">X</span>, <span class="title">Y</span>&gt; <span class="keyword">extends</span> <span class="title">Foo</span>&lt;<span class="title">X</span>&gt;, <span class="title">Bar</span>&lt;<span class="title">Y</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Compiler error: different signatures, same erasure</span></span><br></pre></td></tr></table></figure><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>由于在函数式接口中只有一个抽象函数，因此在将该lambda表达式应用于该方法时不会出现混淆。 Lambda表达式的语法是 <strong>(argument) -&gt; (body)</strong>。现在来看看如何使用lambda表达式写上面的匿名Runnable:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"My Runnable"</span>);</span><br></pre></td></tr></table></figure><p>让我们试着了解上面的lambda表达式中发生了什么。</p><ul><li>Runnable是一个函数式接口，这就是为什么我们可以使用lambda表达式来创建它的实例。</li><li>由于 run() 方法没有参数，我们的lambda表达式也没有参数。</li><li>就像if-else块一样，我们可以避免大括号({})，因为我们在方法体中只有单个语句。对于多个语句，我们必须像使用其他方法一样使用花括号。</li></ul><h2 id="为什么我们需要Lambda表达式"><a href="#为什么我们需要Lambda表达式" class="headerlink" title="为什么我们需要Lambda表达式"></a>为什么我们需要Lambda表达式</h2><h4 id="1、减少代码行数"><a href="#1、减少代码行数" class="headerlink" title="1、减少代码行数"></a>1、减少代码行数</h4><p>使用lambda表达式的一个明显优势是代码量减少了，我们已经看到，我们可以轻松地使用lambda表达式而不是使用匿名类来创建函数接口的实例。</p><h4 id="2、顺序和并行执行支持"><a href="#2、顺序和并行执行支持" class="headerlink" title="2、顺序和并行执行支持"></a>2、顺序和并行执行支持</h4><p>使用lambda表达式的另一个好处是我们可以从Stream API顺序和并行操作支持中受益。</p><p>为了解释这一点，我们举一个简单的例子，我们需要编写一个方法来测试一个数字是否是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Traditional approach</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(number &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;number; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(number % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题在于它本质上是顺序的，如果数字非常大，那么它将花费大量时间。代码的另一个问题是有太多的退出点使其可读性差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Declarative approach</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> number &gt; <span class="number">1</span></span><br><span class="line">&amp;&amp; IntStream.range(<span class="number">2</span>, number).noneMatch(</span><br><span class="line">index -&gt; number % index == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了提高可读性，我们也可以编写如下的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">IntPredicate isDivisible = index -&gt; number % index == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> number &gt; <span class="number">1</span></span><br><span class="line">&amp;&amp; IntStream.range(<span class="number">2</span>, number).noneMatch(</span><br><span class="line">isDivisible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、将行为传递给方法"><a href="#3、将行为传递给方法" class="headerlink" title="3、将行为传递给方法"></a>3、将行为传递给方法</h4><p>我们来看看如何使用lambda表达式来传递一个方法的行为。假设我们必须编写一个方法来对列表中的数字求和，如果它们符合给定的条件。我们可以使用Predicate并编写如下的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumWithCondition</span><span class="params">(List&lt;Integer&gt; numbers, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.parallelStream()</span><br><span class="line">    .filter(predicate)</span><br><span class="line">    .mapToInt(i -&gt; i)</span><br><span class="line">    .sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum of all numbers</span></span><br><span class="line">sumWithCondition(numbers, n -&gt; <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">//sum of all even numbers</span></span><br><span class="line">sumWithCondition(numbers, i -&gt; i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment">//sum of all numbers greater than 5</span></span><br><span class="line">sumWithCondition(numbers, i -&gt; i&gt;<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="4、使用惰性求值效率更高"><a href="#4、使用惰性求值效率更高" class="headerlink" title="4、使用惰性求值效率更高"></a>4、使用惰性求值效率更高</h4><p>使用lambda表达式的另一个优点是惰性求值(lazy evaluation)。假设我们需要编写一个方法来找出3到11范围内的最大奇数并返回它的平方。</p><p>通常我们会为此方法编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSquareOfMaxOdd</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">3</span> &amp;&amp; i &lt; <span class="number">11</span> &amp;&amp; i &gt; max) &#123;</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序总是按顺序运行，但我们可以使用Stream API来实现这一点，并获得Laziness-seeking的好处。我们来看看如何使用Stream API和lambda表达式以函数式编程方式重写此代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSquareOfMaxOdd</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numbers.stream()</span><br><span class="line">.filter(NumberTest::isOdd)      <span class="comment">//Predicate is functional interface and</span></span><br><span class="line">.filter(NumberTest::isGreaterThan3)<span class="comment">// we are using lambdas to initialize it</span></span><br><span class="line">.filter(NumberTest::isLessThan11)<span class="comment">// rather than anonymous inner classes</span></span><br><span class="line">.max(Comparator.naturalOrder())</span><br><span class="line">.map(i -&gt; i * i)</span><br><span class="line">.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGreaterThan3</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLessThan11</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; <span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象并不坏，但它给程序带来了很多冗长的内容。例如，假设我们要创建一个Runnable的实例。通常我们使用下面的匿名类来完成它：&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java 8" scheme="https://maoyunfei.github.io/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性之接口的默认方法和静态方法</title>
    <link href="https://maoyunfei.github.io/java/6376aac3/"/>
    <id>https://maoyunfei.github.io/java/6376aac3/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.330Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8接口新特性包括接口中的静态方法和默认方法。在Java 8之前，我们只能在接口中使用方法声明。但是从Java 8开始，我们可以在接口中使用默认方法和静态方法。</p><a id="more"></a><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>为了在java接口中创建一个默认方法，我们需要在方法签名中使用“<strong>default</strong>”关键字。例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I1 logging::"</span>+str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 log(String str) 是<code>Interface1</code>中的默认方法。现在当一个类实现<code>Interface1</code>时，并不强制为接口的默认方法提供实现。这个特性将帮助我们扩展接口和其他方法，我们所需要的只是提供一个默认实现。</p><p>另一个接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I2 logging::"</span>+str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们知道Java不允许我们继承多个类，因为它会导致“钻石问题”，因为编译器无法决定使用哪个超类方法。使用默认方法，”钻石问题”也会出现在接口上。因为如果一个类同时实现了<code>Interface1</code>和<code>Interface2</code>并且没有实现通用的默认方法，编译器无法决定选择哪一个。</strong>(备注：<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">The diamond problem</a>)</p><p>实现多个接口是Java不可或缺的组成部分，可以在核心Java类以及大多数企业应用程序和框架中找到它。所以为了确保这个问题不会发生在接口中，必须为通用的接口默认方法提供实现。因此，如果一个类正在实现上述两个接口，它将不得不为 log() 方法提供实现，否则编译器将抛出编译时错误。</p><p>一个同时实现<code>Interface1</code>和<code>Interface2</code>的简单类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyClass logging::"</span>+str);</span><br><span class="line">Interface1.print(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有关java接口默认方法的重点："><a href="#有关java接口默认方法的重点：" class="headerlink" title="有关java接口默认方法的重点："></a>有关java接口默认方法的重点：</h3><ul><li>Java 8接口的默认方法将帮助我们扩展接口，而不用担心会破坏实现类。</li><li>Java 8接口默认方法弥合了接口和抽象类之间的差异。</li><li>Java 8接口的默认方法将帮助我们避免utility类，比如所有的Collections类方法都可以在接口本身中提供。</li><li>Java接口的默认方法将帮助我们去除基础实现类，我们可以提供默认的实现，实现类可以选择重写哪一个。</li><li>在接口中引入默认方法的主要原因之一是增强Java 8中的Collections API以支持lambda表达式。</li><li>如果层次结构中的任何类具有相同签名的方法，则默认方法变得不相关。默认方法不能从<code>java.lang.Object</code>中覆盖方法。推理非常简单，这是因为Object是所有java类的基类。所以即使我们把Object类的方法定义为接口中的默认方法，也是无用的，因为总是使用Object类的方法。这就是为什么要避免混淆，我们不能有覆盖Object类方法的默认方法。</li><li>Java接口默认方法也被称为Defender方法或虚拟扩展方法。</li></ul><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>接口静态方法和默认方法类似，除了我们不能在实现类中override它们。这个特性有助于我们避免在实现类中由于不好的实现导致的不当结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isNull(str))</span><br><span class="line">System.out.println(<span class="string">"MyData Print::"</span> + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface Null Check"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str == <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="string">""</span>.equals(str) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看一个实现类，该类具有 isNull() 方法，但实现效果较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataImpl</span> <span class="keyword">implements</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Impl Null Check"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str == <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">MyDataImpl obj = <span class="keyword">new</span> MyDataImpl();</span><br><span class="line">obj.print(<span class="string">""</span>);</span><br><span class="line">obj.isNull(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 isNull(String str) 是一种简单的类方法，它不会覆盖接口方法。例如，如果我们将<code>@Override</code>注释添加到 isNull() 方法，则会导致编译器错误。</p><p>现在，当我们运行应用程序时，我们得到以下输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Interface Null Check</span><br><span class="line">Impl Null Check</span><br></pre></td></tr></table></figure><p>如果我们将接口方法从静态变为默认，我们将得到以下输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Impl Null Check</span><br><span class="line">MyData Print::</span><br><span class="line">Impl Null Check</span><br></pre></td></tr></table></figure><p>Java接口静态方法仅对接口方法可见，如果我们从 MyDataImpl 类中移除 isNull() 方法，我们将无法将其用于 MyDataImpl 对象。像其他静态方法一样，我们可以使用类名调用接口静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = MyData.isNull(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><h3 id="有关java接口静态方法的重点："><a href="#有关java接口静态方法的重点：" class="headerlink" title="有关java接口静态方法的重点："></a>有关java接口静态方法的重点：</h3><ul><li>Java接口的静态方法是接口的一部分，我们不能用它来实现类对象。</li><li>Java接口静态方法适用于提供utility方法，例如空检查，集合排序等。</li><li>Java接口静态方法通过不允许实现类override它们来帮助我们提供安全性。</li><li>我们不能为Object类方法定义接口静态方法，因为“这个静态方法不能从Object隐藏实例方法”，我们会得到编译器错误。这是因为它在java中是不允许的，因为Object是所有类的基类，我们不能有一个类级静态方法和另一个具有相同签名的实例方法。</li><li>我们可以使用java接口的静态方法来移除Collections等utility类，并将它的所有静态方法移到相应的接口中，这很容易找到和使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8接口新特性包括接口中的静态方法和默认方法。在Java 8之前，我们只能在接口中使用方法声明。但是从Java 8开始，我们可以在接口中使用默认方法和静态方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java 8" scheme="https://maoyunfei.github.io/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>聊聊JVM的年轻代</title>
    <link href="https://maoyunfei.github.io/java/24b8c8d9/"/>
    <id>https://maoyunfei.github.io/java/24b8c8d9/</id>
    <published>2018-02-09T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.288Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ifeve.com/jvm-yong-generation/" target="_blank" rel="noopener">本文章来源于并发编程网</a></p><p>堆内存模型大致如下：</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap_memory_model.jpg?raw=true" width="50%" height="50%" align="center"></p><a id="more"></a><h2 id="1-为什么会有年轻代"><a href="#1-为什么会有年轻代" class="headerlink" title="1. 为什么会有年轻代"></a>1. 为什么会有年轻代</h2><p>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><h2 id="2-年轻代中的GC"><a href="#2-年轻代中的GC" class="headerlink" title="2. 年轻代中的GC"></a>2. 年轻代中的GC</h2><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为 <strong>8:1:1</strong> ( 设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了复制算法的缺点 )。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理,直接分配到老年代),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在<strong>年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p><strong>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</strong></p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/young_generation.jpg?raw=true" width="50%" height="50%" align="center"></p><h2 id="3-一个对象的这一辈子"><a href="#3-一个对象的这一辈子" class="headerlink" title="3. 一个对象的这一辈子"></a>3. 一个对象的这一辈子</h2><p>我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p><h2 id="4-有关年轻代的JVM参数"><a href="#4-有关年轻代的JVM参数" class="headerlink" title="4. 有关年轻代的JVM参数"></a>4. 有关年轻代的JVM参数</h2><ul><li>-XX:NewSize和-XX:MaxNewSize</li></ul><p>用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p><ul><li>-XX:SurvivorRatio</li></ul><p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p><ul><li>-XX:+PrintTenuringDistribution</li></ul><p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p><ul><li>-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</li></ul><p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://ifeve.com/jvm-yong-generation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文章来源于并发编程网&lt;/a&gt;&lt;/p&gt;&lt;p&gt;堆内存模型大致如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap_memory_model.jpg?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="JVM" scheme="https://maoyunfei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://maoyunfei.github.io/java/91e798bc/"/>
    <id>https://maoyunfei.github.io/java/91e798bc/</id>
    <published>2018-02-08T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.297Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。<br><a id="more"></a></p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p><p><strong>Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了该被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量</strong>，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下：</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/JMM.jpg?raw=true" width="70%" height="70%" align="center"></p><p>这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分数据。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p><h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)。</p><ul><li><strong>lock</strong>(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><strong>unlock</strong>(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read</strong>(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li><strong>load</strong>(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use</strong>(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign</strong>(赋值)：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store</strong>(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><strong>write</strong>(写入)：作用于工作内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两个特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。<strong>虽然volatile变量在各个线程中是一致的，但是Java里面的运算并非原子操作，所以volatile变量的运算在并发下不能保证安全性。</strong></p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>使用volatile变量的第二个语义是<strong>禁止指令重排序优化</strong>。</p><h3 id="选用volatile的意义"><a href="#选用volatile的意义" class="headerlink" title="选用volatile的意义"></a>选用volatile的意义</h3><p>大多数场景下volatile的总开销要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</p><h2 id="对long和double型变量的特殊规则"><a href="#对long和double型变量的特殊规则" class="headerlink" title="对long和double型变量的特殊规则"></a>对long和double型变量的特殊规则</h2><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据结构(long和double)，在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即<strong>允许虚拟机实现选择可以不保证64位数据结构的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子协定</strong>。</p><h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><p><strong>原子性</strong>：</p><p><strong>可见性</strong>：</p><p><strong>有序性</strong>：</p><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p><strong>程序次序规则</strong>：</p><p><strong>管程锁定规则</strong>：</p><p><strong>volatile变量规则</strong>：</p><p><strong>线程启动规则</strong>：</p><p><strong>线程终止规则</strong>：</p><p><strong>线程中断规则</strong>：</p><p><strong>对象终极规则</strong>：</p><p><strong>传递性</strong>：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="JVM" scheme="https://maoyunfei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="https://maoyunfei.github.io/java/ba66848b/"/>
    <id>https://maoyunfei.github.io/java/ba66848b/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.278Z</updated>
    
    <content type="html"><![CDATA[<p>在Java运行时区域中，程序计数器、虚拟机栈、本地方法栈3个区域随线程的而生，随线程而灭，因此这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要多考虑回收的问题，因此方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配都是动态的，垃圾收集器所关注的是这部分内存。<br><a id="more"></a></p><h2 id="1、判断对象是否“存活”"><a href="#1、判断对象是否“存活”" class="headerlink" title="1、判断对象是否“存活”"></a>1、判断对象是否“存活”</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>引用计数法的实现简单，判定效率也高，但是主流的Java虚拟机里面没有选用其来管理内存，最主要原因是<strong>它很难解决对象之间相互循环引用的问题。</strong></p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索。搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时(从图论来说，从GC Roots到这个对象不可达)，则证明此对象是不可用的。</p><h4 id="在Java语言中，可作为GC-Roots的对象包括下面几种："><a href="#在Java语言中，可作为GC-Roots的对象包括下面几种：" class="headerlink" title="在Java语言中，可作为GC Roots的对象包括下面几种："></a>在Java语言中，可作为GC Roots的对象包括下面几种：</h4><ul><li><strong>虚拟机栈(栈帧中的本地变量表)中引用的对象。</strong></li><li><strong>方法区中类静态属性引用的对象。</strong></li><li><strong>方法区中常量引用的对象。</strong></li><li><strong>本地方法栈中JNI(Native方法)引用的对象。</strong></li></ul><h3 id="1-3-四种引用类型"><a href="#1-3-四种引用类型" class="headerlink" title="1.3 四种引用类型"></a>1.3 四种引用类型</h3><p>引入分为强引用、软引用、弱引用、虚引用4种。</p><ul><li><strong>强引用(Strong Reference)</strong></li></ul><p><code>StringBuilder builder = new StringBuilder();</code></p><p>强引用是默认引用类型，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><ul><li><strong>弱引用(Weak Reference)</strong></li></ul><p><code>WeakReference&lt;StringBuilder&gt; weakBuilder = new WeakReference&lt;StringBuilder&gt;(builder);</code></p><p>弱引用不是默认引用类型，如果需要使用弱引用，则要明确使用<code>WeakReference</code>类。弱引用用来描述非必需的对象。当内存中的对象只被弱引用时，它将可以被垃圾回收。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><ul><li><strong>软引用(Soft Reference)</strong></li></ul><p><code>SoftReference&lt;StringBuilder&gt; softBuilder = new SoftReference&lt;StringBuilder&gt;(builder);</code></p><p>软引用不是默认引用类型，如果需要使用软引用，则要明确使用<code>SoftReference</code>类。软引用用来描述一些还有用但是非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><ul><li><strong>虚引用(Phantom Reference)</strong></li></ul><p><code>PhantomReference&lt;StringBuilder&gt; phantomBuilder = new PhantomReference&lt;StringBuilder&gt;(builder);</code></p><p>虚引用不是默认引用类型，如果需要使用虚引用，则要明确使用<code>PhantomReference</code>类。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象呗收集器回收时收到一个系统通知。</p><h3 id="1-4-两次标记过程"><a href="#1-4-两次标记过程" class="headerlink" title="1.4 两次标记过程"></a>1.4 两次标记过程</h3><p><strong>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</strong> 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p><strong>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</strong> 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，<strong>稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象重新与引用链上任何一个对象建立关联，那么第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</strong></p><p><strong>注意：</strong> 任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h3><p><strong>方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。</strong> 例如常量池中的字面值常量没有任何对象引用它，并且也没有其他地方引用了这个字面量，则这个变量就是废弃变量。<strong>类需要满足3个条件才能算是无用的类：(1)该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；(2)加载该类的ClassLoader已经被回收；(3)该类对应的java.lang.Class对象没有在任何其他地方被引用，无法在任何地方通过反射访问该类的方法。</strong></p><p>虚拟机可以对废弃常量和无用的类进行回收，但并不是一定会回收，是否回收，由虚拟机提供的相关参数进行控制。</p><h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是<strong>效率问题</strong>，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的<strong>内存碎片</strong>。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg?raw=true" width="70%" height="70%" align="center"></p><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。<strong>实现简单，运行高效</strong>。只是这种算法的<strong>代价是将内存缩小为了原来的一半</strong>。现在的商业虚拟机都<strong>采用这种收集算法来回收新生代</strong>。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg?raw=true" width="70%" height="70%" align="center"></p><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低，所以一般不能用于老年代。根据老年代的特点，提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存</strong>。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg?raw=true" width="70%" height="70%" align="center"></p><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java运行时区域中，程序计数器、虚拟机栈、本地方法栈3个区域随线程的而生，随线程而灭，因此这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要多考虑回收的问题，因此方法结束或者线程结束时，内存自然就跟随着回收了。&lt;/p&gt;&lt;p&gt;而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配都是动态的，垃圾收集器所关注的是这部分内存。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="JVM" scheme="https://maoyunfei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot虚拟机对象探秘</title>
    <link href="https://maoyunfei.github.io/java/41b66951/"/>
    <id>https://maoyunfei.github.io/java/41b66951/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.293Z</updated>
    
    <content type="html"><![CDATA[<p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问全过程。<br><a id="more"></a></p><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h2><p>（1）<strong>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</strong></p><p>（2）<strong>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</strong></p><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”(Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间分配给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”(Free List)。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器是，通常采用空闲列表。</p><p>（3）除如何划分可用空间外，还有另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅<strong>修改一个指针所指向的位置，在并发情况下也并不是线程安全的</strong>，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<strong>解决这个问题有两种方案，一种是对分配空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并重新分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</strong></p><p>（4）<strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</strong></p><p>（5）<strong>接下来，虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<strong>这些信息存放在对象的对象头(Object Header)之中</strong>。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p>（6）在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——\&lt;init>方法还没有执行，所有的字段都还为零。所以，<strong>一般来说，执行new指令之后会接着执行\&lt;init>方法</strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><p><strong>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong>。</p><p><strong>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据</strong>，如哈希码(HashCode)、GC分待年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<strong>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中缺无法确定数据的大小。</p><p>接下来的<strong>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容</strong>。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p><p>第三部分<strong>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用</strong>。由于<strong>HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍</strong>，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h2><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。<strong>目前主流的访问方式有使用句柄和直接指针两种</strong>。</p><p>（1）如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与数据类型各自的具体地址信息。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png?raw=true" width="70%" height="70%" align="center"></p><p>（2）如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png?raw=true" width="75%" height="75%" align="center"></p><p>这两种对象访问方式各有优势，<strong>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改</strong>。</p><p><strong>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销</strong>，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。<strong>Sun HotSpot虚拟机是使用直接指针访问方式进行对象访问的</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问全过程。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="JVM" scheme="https://maoyunfei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>运行时数据区域</title>
    <link href="https://maoyunfei.github.io/java/20fd51d6/"/>
    <id>https://maoyunfei.github.io/java/20fd51d6/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.327Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机定义了程序执行期间使用的各种运行时数据区域。有的区域随着虚拟机的启动而存在并随着虚拟机的退出而销毁。有的数据区域是每个线程所独有的，随着线程的创建而创建并随着线程的退出而销毁。</p><p><img src="http://7xrgh9.com1.z0.glb.clouddn.com/16-10-16/6495951.jpg" alt=""><br><a id="more"></a></p><h2 id="1-1-程序计数器（program-counter-register）"><a href="#1-1-程序计数器（program-counter-register）" class="headerlink" title="1.1 程序计数器（program counter register）"></a>1.1 程序计数器（program counter register）</h2><p>程序计数器是一块较小的内存区域，它可以看作是当前线程所执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置，<strong>每个线程都需要有一个独立的程序计数器。位于线程私有内存。</strong></p><p><strong>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为Undefined。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p><h2 id="1-2-Java虚拟机栈-JVM-Stack"><a href="#1-2-Java虚拟机栈-JVM-Stack" class="headerlink" title="1.2 Java虚拟机栈(JVM Stack)"></a>1.2 Java虚拟机栈(JVM Stack)</h2><p><strong>每一个Java虚拟机线程都有一个私有的Java虚拟机栈，与线程同时创建。</strong></p><p><strong>Java虚拟机栈用于存储帧(frame)。每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当方法执行完成的时候，帧就被销毁了，无论方法是正常返回还是抛出未捕获的异常而中断。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。Java虚拟机栈的内存不需要是连续的</strong></p><p>经常所说的栈内存(Stack)指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong></p><h4 id="Java虚拟机栈存在以下两种异常状况："><a href="#Java虚拟机栈存在以下两种异常状况：" class="headerlink" title="Java虚拟机栈存在以下两种异常状况："></a>Java虚拟机栈存在以下两种异常状况：</h4><ul><li><strong>如果线程计算请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</strong></li><li><strong>如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展)，并且尝试扩展时无法申请到足够的内存或者没有足够的内存可用于为新线程创建初始Java虚拟机栈时，将抛出OutOfMemoryError异常。</strong></li></ul><h2 id="1-3-本地方法栈-Native-Method-Stack"><a href="#1-3-本地方法栈-Native-Method-Stack" class="headerlink" title="1.3 本地方法栈(Native Method Stack)"></a>1.3 本地方法栈(Native Method Stack)</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务</strong>。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="1-4-堆-Heap"><a href="#1-4-堆-Heap" class="headerlink" title="1.4 堆(Heap)"></a>1.4 堆(Heap)</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。<strong>Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong></p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。<strong>Java堆可以位于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有足够内存完成实例分配，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。</strong></p><h2 id="1-5-方法区-Method-Area"><a href="#1-5-方法区-Method-Area" class="headerlink" title="1.5 方法区(Method Area)"></a>1.5 方法区(Method Area)</h2><p><strong>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，例如运行时常量池、属性和方法的数据、方法和构造器的代码，以及类和接口初始化和实例初始化中使用的特殊方法。</strong></p><p>方法区不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。<strong>如果方法区的内存无法满足分配需求时，将抛出OutOfMemoryError异常。</strong></p><h2 id="1-6-运行时常量池-Run-Time-Constant-Pool"><a href="#1-6-运行时常量池-Run-Time-Constant-Pool" class="headerlink" title="1.6 运行时常量池(Run-Time Constant Pool)"></a>1.6 运行时常量池(Run-Time Constant Pool)</h2><p><strong>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</strong></p><p>每一个运行时常量池都从JVM方法区分配内存，类或接口的运行时常量池是在Java虚拟机创建类或接口时构建的。</p><p>运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的变量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p><strong>当创建类或接口时，如果无法从JVM方法区申请足够的内存来构造运行时常量池时，将抛出OutOfMemoryError异常。</strong></p><p><img src="http://ifeve.com/wp-content/uploads/2015/05/JUtH_20121024_RuntimeDataAreas_1_MemoryModel-1.png" alt=""></p><h2 id="重要总结："><a href="#重要总结：" class="headerlink" title="重要总结："></a>重要总结：</h2><p><strong>1. 永久代的变更到废除</strong></p><p><strong>变更(字符串常量池移到了堆)：</strong></p><p>在JDK6以及其前期的JDK版本中，永久代用于存储类信息和字符串常量池。</p><p>在JDK7中，永久代只用于存储类信息，字符串常量池在堆中存储。</p><p><strong>废弃(被Metaspace取代)：</strong></p><p>在JDK7以及其前期的JDK版本中，堆内存通常被分为两块区域，新生代(young<br>generation)和老年代(old generation)：显示如下图：</p><p>永久代(Permanent Generation for<br>VM Matedata)和代码缓存区(code cache area)属于非堆内存。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap.jpg?raw=true" width="50%" height="50%" align="center"></p><p>在JDK8中把存放元数据的永久代废弃，类信息存储到了在本地内存(native memory)<br>中叫Metaspace的区域，JDK8中JVM堆内存结构就变成了如下：</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap_2.jpg?raw=true" width="50%" height="50%" align="center"></p><p><strong>2. 方法区位置变化</strong></p><p>在JDK7以及之前的版本，方法区是永久代的一部分，在JDK8中方法区是Metaspace的一部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机定义了程序执行期间使用的各种运行时数据区域。有的区域随着虚拟机的启动而存在并随着虚拟机的退出而销毁。有的数据区域是每个线程所独有的，随着线程的创建而创建并随着线程的退出而销毁。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://7xrgh9.com1.z0.glb.clouddn.com/16-10-16/6495951.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="JVM" scheme="https://maoyunfei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hash冲突解决方案</title>
    <link href="https://maoyunfei.github.io/other/eebb0c54/"/>
    <id>https://maoyunfei.github.io/other/eebb0c54/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-03-04T09:40:15.520Z</updated>
    
    <content type="html"><![CDATA[<p>开放地址法(open addressing)</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/hash_conflict.jpg?raw=true" alt=""><br><a id="more"></a><br><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/hash_conflict_2.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开放地址法(open addressing)&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/hash_conflict.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="https://maoyunfei.github.io/categories/other/"/>
    
    
      <category term="hash" scheme="https://maoyunfei.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Java String Constant Pool (Java字符串常量池)</title>
    <link href="https://maoyunfei.github.io/java/e52216a2/"/>
    <id>https://maoyunfei.github.io/java/e52216a2/</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.282Z</updated>
    
    <content type="html"><![CDATA[<p>当你在Java中声明一个新的字符串时，在这个场景下有一些有趣的事情发生。</p><p>这是一个基本的字符串声明，我们创建了一个新的字符串变量<code>employee</code>并给它赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String employee = <span class="string">"Edgar Allen Poe"</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Java不仅会创建变量<code>employee</code>，而且还会为内存中的字面值“Edgar Allen Poe”分配空间。内存中的这个区域被称为<strong>字符串常量池</strong>。它就像程序的其他部分可用的字符串值池。</p><h2 id="重用字符串常量池中的值"><a href="#重用字符串常量池中的值" class="headerlink" title="重用字符串常量池中的值"></a>重用字符串常量池中的值</h2><p>现在，如果你创建了另一个变量，比如<code>employee2</code>，并且还给了它一个“Edgar Allen Poe”的值，那么Java只是重用了已经在池中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String employee2 = <span class="string">"Edgar Allen Poe"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/string_constant_pool_1.jpg?raw=true" width="335px" height="200px" align="center"></p><p>你会注意到字符串常量池位于内存的<strong>堆</strong>部分。</p><h2 id="创建一个新的字符串实例"><a href="#创建一个新的字符串实例" class="headerlink" title="创建一个新的字符串实例"></a>创建一个新的字符串实例</h2><p>如果你创建String类的新实例，则常量池的工作方式不同。让我们创建另一个变量<code>employee3</code>，并给它相同的字面值。但是，这次我们将创建一个String类的新实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String employee3 = <span class="keyword">new</span> String(<span class="string">"Edgar Allen Poe"</span>);</span><br></pre></td></tr></table></figure><p>当这个代码被处理时，Java将会有所不同。而不是再次使用相同的字面值，它会在内存中创建一个新的值。在这种情况下，它不会在字符串常量池中创建它，而是在内存堆中创建它。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/string_constant_pool_2.jpg?raw=true" width="335px" height="201px" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你在Java中声明一个新的字符串时，在这个场景下有一些有趣的事情发生。&lt;/p&gt;&lt;p&gt;这是一个基本的字符串声明，我们创建了一个新的字符串变量&lt;code&gt;employee&lt;/code&gt;并给它赋值。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String employee = &lt;span class=&quot;string&quot;&gt;&quot;Edgar Allen Poe&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://maoyunfei.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java -jar启动命令</title>
    <link href="https://maoyunfei.github.io/java/309440ba/"/>
    <id>https://maoyunfei.github.io/java/309440ba/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以下是java启动命令的语法说明"><a href="#以下是java启动命令的语法说明" class="headerlink" title="以下是java启动命令的语法说明:"></a>以下是java启动命令的语法说明:</h2><p>（<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">官方文档说明</a>）</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/java%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95.jpg?raw=true" width="350" height="350" align="center"></p><a id="more"></a><h2 id="以下是-options-的说明以及一些常用的"><a href="#以下是-options-的说明以及一些常用的" class="headerlink" title="以下是[options]的说明以及一些常用的:"></a>以下是[options]的说明以及一些常用的:</h2><p><strong>1、Standard Options</strong> 所有运行环境都支持</p><ul><li>-D 用于设置系统变量，由于spring boot会从系统属性读取属性，所以使用<code>@Value(&quot;myDir&quot;)</code>即可获取。</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-D%20option.jpg?raw=true" width="50%" height="50%" align="center"></p><ul><li>-jar 用于指定启动的jar文件，jar文件的manifest必须知道Main-Class</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-jar%20option.jpg?raw=true" width="150%" height="150%" align="center"></p><p><strong>2、Nonstandard Options</strong> 由Java HotSpot VMs默认提供</p><ul><li>-Xmn 设置新生代的大小</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-Xmn%20option.jpg?raw=true" width="30%" height="30%" align="center"></p><ul><li>-Xms 设置内存分配池的最小值，即初始值</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-Xms%20option.jpg?raw=true" align="center"></p><ul><li>-Xmx 设置内存分配池的最大值</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-Xmx%20option.jpg?raw=true" align="center"></p><p>对于服务器部署，-Xms和-Xmx通常设置为相同的值。</p><h2 id="以下是-arguments-说明："><a href="#以下是-arguments-说明：" class="headerlink" title="以下是[arguments]说明："></a>以下是[arguments]说明：</h2><p>语法为 <strong>–{name}={value}</strong></p><p>例如：<br><code>java -jar app.jar --name=&quot;Spring&quot;</code> 。由于spring boot会从command line argument读取属性，所以使用<code>@Value(&quot;name&quot;)</code>即可获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以下是java启动命令的语法说明&quot;&gt;&lt;a href=&quot;#以下是java启动命令的语法说明&quot; class=&quot;headerlink&quot; title=&quot;以下是java启动命令的语法说明:&quot;&gt;&lt;/a&gt;以下是java启动命令的语法说明:&lt;/h2&gt;&lt;p&gt;（&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档说明&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/java%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95.jpg?raw=true&quot; width=&quot;350&quot; height=&quot;350&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://maoyunfei.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Executor,ExecutorService和Executors间的不同</title>
    <link href="https://maoyunfei.github.io/java/8542269d/"/>
    <id>https://maoyunfei.github.io/java/8542269d/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.341Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yemengying.com/2017/03/17/difference-between-executor-executorService/" target="_blank" rel="noopener">文章摘录自博客</a></p><p><span style="color:#ff4500"><code>java.util.concurrent.Executor</code>, <code>java.util.concurrent.ExecutorService</code>, <code>java.util.concurrent.Executors</code></span>这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免<span style="color:#ff4500"><code>&quot;java.lang.OutOfMemoryError: unable to create new native thread&quot;</code></span>之类的错误。</p><p>在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：<code>FixedThreadPool</code>(包含固定数目的线程)，<code>CachedThreadPool</code>(可根据需要创建新的线程)等等。<br><a id="more"></a></p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor，ExecutorService，和 Executors 最主要的区别是 Executor 是一个抽象层面的核心接口(大致代码如下)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于<span style="color:#ff4500"><code>java.lang.Thread</code></span>类将任务和执行耦合在一起， Executor 将任务本身和执行任务分离，可以阅读 <a href="http://javarevisited.blogspot.sg/2016/12/difference-between-thread-and-executor.html" target="_blank" rel="noopener">difference between Thread and Executor</a> 来了解 Thread 和 Executor 间更多的不同。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>ExecutorService 接口 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。当调用<span style="color:#ff4500"><code>shutDown</code></span>方法时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。</p><p>Future 对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 Future 是否已经有了结果，如果任务已经执行完成，就可以通过 Future.get( ) 方法获得执行结果。需要注意的是，Future.get( ) 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。</p><p>通过 ExecutorService.submit( ) 方法返回的 Future 对象，还可以取消任务的执行。Future 提供了 <span style="color:#ff4500"><code>cancel()</code></span>方法用来取消执行 pending 中的任务。</p><p>ExecutorService 部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。</p><p>Executors 部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executor-vs-ExecutorService-vs-Executors"><a href="#Executor-vs-ExecutorService-vs-Executors" class="headerlink" title="Executor vs ExecutorService vs Executors"></a>Executor vs ExecutorService vs Executors</h2><p>正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解：</p><ul><li>Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口</li><li>Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 <span style="color:#ff4500"><code>execute()</code></span>方法用来接收一个<span style="color:#ff4500"><code>Runnable</code></span>接口的对象，而 ExecutorService 接口中的 <span style="color:#ff4500"><code>submit()</code></span>方法可以接受<span style="color:#ff4500"><code>Runnable</code></span>和<span style="color:#ff4500"><code>Callable</code></span>接口的对象。</li><li><p>Executor 和 ExecutorService 接口第三个区别是 Executor 中的 <span style="color:#ff4500"><code>execute()</code></span>方法不返回任何结果，而 ExecutorService 中的 <span style="color:#ff4500"><code>submit()</code></span>方法可以通过一个 Future 对象返回运算结果。</p></li><li><p>Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 <span style="color:#ff4500"><code>shutDown()</code></span>方法终止线程池。可以通过 <a href="http://www.amazon.com/dp/0321349601/?tag=javamysqlanta-20" target="_blank" rel="noopener">《Java Concurrency in Practice》</a> 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。</p></li><li><p>Executors 类提供工厂方法用来创建不同类型的线程池。比如: <span style="color:#ff4500"><code>newSingleThreadExecutor()</code></span>创建一个只有一个线程的线程池，<span style="color:#ff4500"><code>newFixedThreadPool(int numOfThreads)</code></span>来创建固定线程数的线程池，<span style="color:#ff4500"><code>newCachedThreadPool()</code></span>可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表列出了 Executor 和 ExecutorService 的区别：</p><table><thead><tr><th style="text-align:left">Executor</th><th style="text-align:left">ExecutorService</th></tr></thead><tbody><tr><td style="text-align:left">Executor 是 Java 线程池的核心接口，用来并发执行提交的任务</td><td style="text-align:left">ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法</td></tr><tr><td style="text-align:left">提供execute()方法用来提交任务</td><td style="text-align:left">提供submit()方法用来提交任务</td></tr><tr><td style="text-align:left">execute()方法无返回值</td><td style="text-align:left">submit()方法返回Future对象，可用来获取任务执行结果</td></tr><tr><td style="text-align:left">不能取消任务</td><td style="text-align:left">可以通过Future.cancel()取消pending中的任务</td></tr><tr><td style="text-align:left">没有提供和关闭线程池有关的方法</td><td style="text-align:left">提供了关闭线程池的方法</td></tr></tbody></table><h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>个人觉得，利用 Executors 类提供的工厂方法来创建一个线程池是很方便，但对于需要根据实际情况自定义线程池某些参数的场景，就不太适用了。</p><p>举个例子：<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：</p><ul><li>AbortPolicy: 直接抛异常</li><li>CallerRunsPolicy: 用调用者的线程来运行任务</li><li>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务</li><li>DiscardPolicy 直接将新任务丢弃</li></ul><p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p><p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p><p>当然，在使用 Spring 框架的项目中，也可以使用 Spring 提供的 ThreadPoolTaskExecutor 类来创建线程池。ThreadPoolTaskExecutor 与 ThreadPoolExecutor 类似，也提供了许多参数用来自定义线程池，比如：核心线程池大小，线程池最大数量，饱和策略，线程活动保持时间等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://yemengying.com/2017/03/17/difference-between-executor-executorService/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章摘录自博客&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color:#ff4500&quot;&gt;&lt;code&gt;java.util.concurrent.Executor&lt;/code&gt;, &lt;code&gt;java.util.concurrent.ExecutorService&lt;/code&gt;, &lt;code&gt;java.util.concurrent.Executors&lt;/code&gt;&lt;/span&gt;这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免&lt;span style=&quot;color:#ff4500&quot;&gt;&lt;code&gt;&amp;quot;java.lang.OutOfMemoryError: unable to create new native thread&amp;quot;&lt;/code&gt;&lt;/span&gt;之类的错误。&lt;/p&gt;&lt;p&gt;在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：&lt;code&gt;FixedThreadPool&lt;/code&gt;(包含固定数目的线程)，&lt;code&gt;CachedThreadPool&lt;/code&gt;(可根据需要创建新的线程)等等。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://maoyunfei.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>equals()和hashCode()</title>
    <link href="https://maoyunfei.github.io/java/554520e5/"/>
    <id>https://maoyunfei.github.io/java/554520e5/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.305Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dzone.com/articles/working-with-hashcode-and-equals-in-java" target="_blank" rel="noopener">原文链接</a></p><p>默认情况下，Java超类<code>java.lang.Object</code>提供了两种比较对象的重要方法：<code>equals()</code>和<code>hashCode()</code>。在大型项目中实现多个类之间的交互时，这些方法变得非常有用。在本文中，我们将讨论这些方法之间的关系，它们的默认实现以及强制开发人员为每个方法提供自定义实现的情况。<br><a id="more"></a></p><h2 id="方法定义和默认实现"><a href="#方法定义和默认实现" class="headerlink" title="方法定义和默认实现"></a>方法定义和默认实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>equal()</code>方法：JDK提供的默认实现是基于内存位置的 - <strong>当且仅当它们存储在同一个内存地址中时，两个对象是相等的。</strong></li><li><code>hashCode()</code>方法：默认实现是个<strong>本地方法</strong>。需要满足三个约定：(1) 无论什么时间，在<strong>同一个应用内</strong>执行多次应该返回相同的值。(2) 如果两个对象的<code>equals()</code>方法返回<code>true</code>，那么它们的<code>hashCode()</code>必须相同。(3) 如果两个对象的<code>equals()</code>方法返回<code>false</code>，那么它们的<code>hashCode()</code>可以相同，也可以不同。</li></ul><h2 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals()"></a>重写equals()</h2><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.programmer.gate.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Student))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getId() == ((Student) obj).getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals-With-ArrayList"><a href="#equals-With-ArrayList" class="headerlink" title="equals() With ArrayList"></a>equals() With ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashcodeEquals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student alex = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"Alex"</span>);</span><br><span class="line">        List &lt; Student &gt; studentsLst = <span class="keyword">new</span> ArrayList &lt; Student &gt; ();</span><br><span class="line">        studentsLst.add(alex);</span><br><span class="line">        System.out.println(<span class="string">"Arraylist size = "</span> + studentsLst.size());</span><br><span class="line">        System.out.println(<span class="string">"Arraylist contains Alex = "</span> + studentsLst.contains(<span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"Alex"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arraylist size = <span class="number">1</span></span><br><span class="line">Arraylist contains Alex = <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>原因是<code>ArrayList</code>的<code>contains()</code>方法内部是调用的对象的<code>equals()</code>方法。</strong></p><h2 id="重写hashCode"><a href="#重写hashCode" class="headerlink" title="重写hashCode()"></a>重写hashCode()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals-With-HashSet"><a href="#equals-With-HashSet" class="headerlink" title="equals() With HashSet"></a>equals() With HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashcodeEquals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student alex1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"Alex"</span>);</span><br><span class="line">        Student alex2 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"Alex"</span>);</span><br><span class="line">        HashSet &lt; Student &gt; students = <span class="keyword">new</span> HashSet &lt; Student &gt; ();</span><br><span class="line">        students.add(alex1);</span><br><span class="line">        students.add(alex2);</span><br><span class="line">        System.out.println(<span class="string">"HashSet size = "</span> + students.size());</span><br><span class="line">        System.out.println(<span class="string">"HashSet contains Alex = "</span> + students.contains(<span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"Alex"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet size = <span class="number">1</span></span><br><span class="line">HashSet contains Alex = <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><code>HashSet</code>将其元素存储在内存桶中。每个桶都链接到一个特定的哈希码。当调用<code>students.add(alex1)</code>时，Java在存储桶中存储<code>alex1</code>并将其链接到<code>alex1.hashCode()</code>的值。现在任何时候，一个具有相同散列码的元素被插入到集合中，它将会替换掉<code>alex1</code>。但是，由于<code>alex2</code>具有不同的散列码，它将被存储在一个单独的存储桶中，并被视为完全不同的对象。</p><p>现在，当<code>HashSet</code>在其中搜索一个元素时，它首先生成元素的哈希码并查找与这个哈希码对应的一个桶。</p><p><strong>这同样适用于<code>HashMap</code>，<code>HashTable</code>或任何使用散列机制来存储元素的数据结构。<code>hashCode()</code>用于散列到桶，<code>equals()</code>用于判断对象是否相同。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dzone.com/articles/working-with-hashcode-and-equals-in-java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;默认情况下，Java超类&lt;code&gt;java.lang.Object&lt;/code&gt;提供了两种比较对象的重要方法：&lt;code&gt;equals()&lt;/code&gt;和&lt;code&gt;hashCode()&lt;/code&gt;。在大型项目中实现多个类之间的交互时，这些方法变得非常有用。在本文中，我们将讨论这些方法之间的关系，它们的默认实现以及强制开发人员为每个方法提供自定义实现的情况。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://maoyunfei.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Understanding Eureka Peer to Peer Communication</title>
    <link href="https://maoyunfei.github.io/spring/7b50bf88/"/>
    <id>https://maoyunfei.github.io/spring/7b50bf88/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.765Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication" target="_blank" rel="noopener">原文链接</a></p><p>Eureka client尝试去和相同zone的Eureka Server通信。如果相同zone的server不存在或者通信有问题，client就会转到其他zone的server。</p><p>一旦服务器开始接收流量，在服务器上执行的所有操作都将被复制到服务器所知道的所有对等节点。如果某个操作由于某种原因而失败，那么该信息将在服务器之间下一次心跳时核对后复制。</p><p>当Eureka server恢复，它尝试从邻居节点获取所有实例的注册信息。如果从一个节点获取信息存在问题，在它放弃之前，它将尝试所有的对等节点。如果Eureka server能够成功获取所有实例信息，则会根据该信息设置应该接收的“续约”阈值。如果任何时候，“续约”低于设置的该阈值百分比(在15分钟内低于85%),Eureka server停止过期实例来保护当前实例的注册信息。</p><p>在Neflix,上面的保护称为“自我保护”模式，主要用在一组client和Eureka server之间存在网络分区的情况下的保护。在这种场景下，Eureka server尝试去保护已经拥有的信息。如果发生大规模的故障，在这种情况下，可能会导致client获得已经不存在的实例。client必须确保它们对于返回不存在或不响应的实例的Eureka server具有弹性。在这些情况下，最好的保护是快速超时并尝试其他服务器。</p><p>在这种情况下，如果Eureka server无法从邻居节点获取注册表信息，则会等待几分钟（5分钟），以便客户端可以注册其信息。server尽量不提供部分信息给client，而是通过将流量倾斜到仅一组实例并会导致容量问题。</p><p>如此处所述，Eureka server使用在Eureka client和server之间使用的相同机制相互通信。<br><a id="more"></a></p><h2 id="What-happens-during-network-outages-between-Peers"><a href="#What-happens-during-network-outages-between-Peers" class="headerlink" title="What happens during network outages between Peers?"></a>What happens during network outages between Peers?</h2><h3 id="在peers之间失去网络通信的情况下，下列事情将发生"><a href="#在peers之间失去网络通信的情况下，下列事情将发生" class="headerlink" title="在peers之间失去网络通信的情况下，下列事情将发生"></a>在peers之间失去网络通信的情况下，下列事情将发生</h3><ul><li>peers之间的心跳复制可能会失败，并且Eureka server检测到这种情况然后进入自我保护模式来保护当前状态。</li><li>注册可能发生在孤立的Eureka server上，有些client可能会反映新的注册信息，而其他client可能不会。(备注：由于孤立的Eureka server无法与其他server共享注册信息)</li><li>在网络连接恢复到稳定状态后，情况会自动更正。当peers能够正常通信时，注册信息会自动被传输到没有这些信息的Eureka server上。(备注：即网络恢复后，Eureka server之间会自动同步共享注册信息)</li></ul><p>最重要的是，在网络中断期间，Eureka server尝试尽可能地具有弹性，但在此期间，client可能会有不同的server视图。(备注：Eureka server存在网络分区时，多个server之间无法同步注册信息，导致每个server上的信息可能不同，所以client可能会看到不同的server视图)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Eureka client尝试去和相同zone的Eureka Server通信。如果相同zone的server不存在或者通信有问题，client就会转到其他zone的server。&lt;/p&gt;&lt;p&gt;一旦服务器开始接收流量，在服务器上执行的所有操作都将被复制到服务器所知道的所有对等节点。如果某个操作由于某种原因而失败，那么该信息将在服务器之间下一次心跳时核对后复制。&lt;/p&gt;&lt;p&gt;当Eureka server恢复，它尝试从邻居节点获取所有实例的注册信息。如果从一个节点获取信息存在问题，在它放弃之前，它将尝试所有的对等节点。如果Eureka server能够成功获取所有实例信息，则会根据该信息设置应该接收的“续约”阈值。如果任何时候，“续约”低于设置的该阈值百分比(在15分钟内低于85%),Eureka server停止过期实例来保护当前实例的注册信息。&lt;/p&gt;&lt;p&gt;在Neflix,上面的保护称为“自我保护”模式，主要用在一组client和Eureka server之间存在网络分区的情况下的保护。在这种场景下，Eureka server尝试去保护已经拥有的信息。如果发生大规模的故障，在这种情况下，可能会导致client获得已经不存在的实例。client必须确保它们对于返回不存在或不响应的实例的Eureka server具有弹性。在这些情况下，最好的保护是快速超时并尝试其他服务器。&lt;/p&gt;&lt;p&gt;在这种情况下，如果Eureka server无法从邻居节点获取注册表信息，则会等待几分钟（5分钟），以便客户端可以注册其信息。server尽量不提供部分信息给client，而是通过将流量倾斜到仅一组实例并会导致容量问题。&lt;/p&gt;&lt;p&gt;如此处所述，Eureka server使用在Eureka client和server之间使用的相同机制相互通信。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Understanding eureka client server communication</title>
    <link href="https://maoyunfei.github.io/spring/55dcd732/"/>
    <id>https://maoyunfei.github.io/spring/55dcd732/</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.764Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/eureka/wiki/Understanding-eureka-client-server-communication" target="_blank" rel="noopener">原文链接</a></p><h2 id="About-Instance-Statuses"><a href="#About-Instance-Statuses" class="headerlink" title="About Instance Statuses"></a>About Instance Statuses</h2><p>默认的，Eureka client开始状态是 <strong>STARTING</strong>，这为了在实例能够提供服务之前，给它做应用初始化的时间。之后应用可以加入到可提供服务中通过将状态变更为 <strong>UP</strong>。</p><p><code>ApplicationInfoManager.getInstance().setInstanceStatus(InstanceStatus.UP)</code></p><p>应用也可以注册健康检查的callback，这可以选择性地将实例状态变为 <strong>DOWN</strong>。</p><p>在Neflix中，还有一个 <strong>OUT_ OF_ SERVICE</strong> 状态,表明该实例不可提供服务中。<br><a id="more"></a></p><h2 id="Eureka-Client-Operations"><a href="#Eureka-Client-Operations" class="headerlink" title="Eureka Client Operations"></a>Eureka Client Operations</h2><p>Eureka client首先尝试去和相同zone的Eureka Server连接，如果它不能发现服务端，它将转向其他zone。</p><h3 id="Eureka-client通过以下方式和服务端交互"><a href="#Eureka-client通过以下方式和服务端交互" class="headerlink" title="Eureka client通过以下方式和服务端交互"></a>Eureka client通过以下方式和服务端交互</h3><ul><li><strong>Register</strong></li></ul><blockquote><p>Eurek Client向Eureka server注册运行实例的信息。注册发生在第一次心跳(在30秒之后)。</p></blockquote><ul><li><strong>Renew</strong></li></ul><blockquote><p>Eureka client需要通过每30秒发送心跳来“续约”。“续约”信号告诉Eureka server该实例仍然是可用的。如果server在90秒没有收到“续约”，他将从注册列表移除该实例。不去改变“续约”周期是明智的，因为server使用这个信息去判断在client和server之间的通信是否有普遍的问题。(备注：例如网络分区问题)</p></blockquote><ul><li><strong>Fetch Registry</strong></li></ul><blockquote><p>Eureka client从server获取注册信息并缓存在本地。之后，client使用这个信息去发现其他的服务。注册信息被周期性的更新(每30秒)，通过获取上一个读取周期和当前读取周期之间的增量更新。增量信息在server中保持较长时间（约3分钟），因此增量提取可能会再次返回相同的实例。Eureka client会自动处理重复的信息。</p></blockquote><blockquote><p>获取增量之后，Eureka client和server通过比较server返回的实例数量来比对信息，如果由于某些原因信息不匹配，整个注册信息将重新提取。Eureka server缓存压缩的增量payload、整个注册表，以及每个应用程序相同的未压缩信息。payload支持JSON和XML格式。Eureka client通过jersey apache client获取压缩的JSON格式的信息。</p></blockquote><ul><li><strong>Cancel</strong></li></ul><blockquote><p>Eureka client在shutdown时给Eureka server发送一个cancel请求。Eureka server将从服务的实例注册信息中移除该实例，这有效得将实例从负载中移除。(备注：通过linux命令 kill -15应用程序将收到shutdown通知，kill -9则收不到通知)</p></blockquote><blockquote><p>当Eureka client shutdown时，应用应该保证去调用以下方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent()</span><br></pre></td></tr></table></figure><p></p></blockquote><ul><li><strong>Time Lag</strong></li></ul><blockquote><p>Eureka client的所有操作会花费一定时间反映到Eureka server和其他的clients。这是因为Eureka server上有payload的缓存，它定期刷新以获取新的信息。Eureka client也会定期刷新增量信息。因此，这可能花费长达2分钟的时间去把变更传播到所有的Eureka client。</p></blockquote><ul><li><strong>Communication mechanism</strong></li></ul><blockquote><p>默认的，Eureka client使用Jersey,XStream技术和JSON 格式的payload去和Eureka Server交流。你也可以使用你选择的机制来覆盖默认的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/eureka/wiki/Understanding-eureka-client-server-communication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;About-Instance-Statuses&quot;&gt;&lt;a href=&quot;#About-Instance-Statuses&quot; class=&quot;headerlink&quot; title=&quot;About Instance Statuses&quot;&gt;&lt;/a&gt;About Instance Statuses&lt;/h2&gt;&lt;p&gt;默认的，Eureka client开始状态是 &lt;strong&gt;STARTING&lt;/strong&gt;，这为了在实例能够提供服务之前，给它做应用初始化的时间。之后应用可以加入到可提供服务中通过将状态变更为 &lt;strong&gt;UP&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ApplicationInfoManager.getInstance().setInstanceStatus(InstanceStatus.UP)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;应用也可以注册健康检查的callback，这可以选择性地将实例状态变为 &lt;strong&gt;DOWN&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;在Neflix中，还有一个 &lt;strong&gt;OUT_ OF_ SERVICE&lt;/strong&gt; 状态,表明该实例不可提供服务中。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Circuit Breaker--Hystrix</title>
    <link href="https://maoyunfei.github.io/spring/da1cb016/"/>
    <id>https://maoyunfei.github.io/spring/da1cb016/</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Hystrix-Clients"><a href="#1-Hystrix-Clients" class="headerlink" title="1. Hystrix Clients"></a>1. Hystrix Clients</h2><p><a href="http://cloud.spring.io/spring-cloud-static/Finchley.M2/#_circuit_breaker_hystrix_clients" target="_blank" rel="noopener">原文链接</a></p><p>Netflix创建了一个实现了<a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">circuit breaker模式</a>的叫做<a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a>的库。在一个微服务架构中通常有多层的服务调用，如下图。<br><a id="more"></a><br><img src="http://cloud.spring.io/spring-cloud-static/Finchley.M2/images/HystrixGraph.png" style="zoom:50%"><em>Microservice Graph</em></p><p>一个底层的服务失败可以导致级联的直到用户的失败。在一个由 <code>metrics.rollingStats.timeInMilliseconds</code>(默认10秒)定义的默认窗口内，当请求一个指定的服务次数大于<code>circuitBreaker.requestVolumeThreshold</code>(默认20)并且失败率大于<code>circuitBreaker.errorThresholdPercentage</code>(默认50%)时，断路打开，请求不会发出。在发生错误或者短路时，开发者可以提供fallback。</p><p><img src="http://cloud.spring.io/spring-cloud-static/Finchley.M2/images/HystrixFallback.png" style="zoom:50%"><em>Hystrix fallback prevents cascading failures</em></p><p>断路阻止了级联失败，并且允许高负载或者失败的服务有时间去恢复。fallback可以是另一个Hystrix保护的调用，静态数据或者空值。fallback可能是链式的，导致第一个fallback做的一些业务调用又回退到静态数据。</p><h3 id="1-1-如何引入Hystrix"><a href="#1-1-如何引入Hystrix" class="headerlink" title="1.1 如何引入Hystrix"></a>1.1 如何引入Hystrix</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class StoreIntegration &#123;</span><br><span class="line"></span><br><span class="line">    @HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</span><br><span class="line">    public Object getStores(Map&lt;String, Object&gt; parameters) &#123;</span><br><span class="line">        //do stuff that might fail</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object defaultStores(Map&lt;String, Object&gt; parameters) &#123;</span><br><span class="line">        return /* something useful */;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@HystrixCommand</code>由一个名为“javanica”的Netflix contrib库提供。Spring Cloud自动将包含该注释的Spring bean包装在连接到Hystrix断路器的代理中。断路器计算何时打开和关闭电路，以及在发生故障时该怎么办。</p><p>要配置<code>@HystrixCommand</code>，您可以使用带有<code>@HystrixProperty</code>注释列表的<code>commandProperties</code>属性。<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration" target="_blank" rel="noopener">这里</a>查看细节。<a href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_blank" rel="noopener">Hystrix properties</a>。</p><h3 id="1-2-传播安全上下文或者使用Spring-Scopes"><a href="#1-2-传播安全上下文或者使用Spring-Scopes" class="headerlink" title="1.2 传播安全上下文或者使用Spring Scopes"></a>1.2 传播安全上下文或者使用Spring Scopes</h3><p>如果你想传播一些线程本地上下文到@HystrixCommand中，用默认声明是不起作用的，因为它在一个线程池中执行命令。当调用者使用一些配置或者直接在注解中让它去使用一个不同的隔离策略，你可以切换Hystrix去使用同一个线程。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = &quot;stubMyService&quot;,</span><br><span class="line">    commandProperties = &#123;</span><br><span class="line">      @HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果使用<code>@SessionScope</code>或<code>@RequestScope</code>，则同样适用。你将知道何时需要执行此操作，因为一个运行时异常表示无法找到该scope内的上下文。</p><p>你也可以设置<code>hystrix.shareSecurityContext</code>属性为<code>true</code>。这样会自动配置一个Hystrix并发策略插件，它将会把<code>SecurityContext</code>从你的主线程传递到Hystrix命令使用的线程。Hystrix不支持注册多个hystrix并发策略，所以可以通过声明你自己的<code>HystrixConcurrencyStrategy</code> bean来扩展。Spring cloud将在你的spring上下文中查找并把它封装进它自己的插件。</p><h3 id="1-3-健康指标"><a href="#1-3-健康指标" class="headerlink" title="1.3 健康指标"></a>1.3 健康指标</h3><p>连接断路器的状态也暴露在应用程序的<code>/health</code>端点中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;hystrix&quot;: &#123;</span><br><span class="line">        &quot;openCircuitBreakers&quot;: [</span><br><span class="line">            &quot;StoreIntegration::getStoresByLocationLink&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;status&quot;: &quot;CIRCUIT_OPEN&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;status&quot;: &quot;UP&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Hystrix指标流"><a href="#1-4-Hystrix指标流" class="headerlink" title="1.4 Hystrix指标流"></a>1.4 Hystrix指标流</h3><p>添加spring-boot-starter-actuator依赖来启用Hystrix指标流。这将暴露管理端点<code>/hystrix.stream</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-Hystrix-Dashboard"><a href="#2-Hystrix-Dashboard" class="headerlink" title="2. Hystrix Dashboard"></a>2. Hystrix Dashboard</h2><p><a href="http://cloud.spring.io/spring-cloud-static/Finchley.M2/#_circuit_breaker_hystrix_dashboard" target="_blank" rel="noopener">原文链接</a></p><p>Hystrix的主要优点之一就是它收集的关于每个HystrixCommand的指标集合。Hystrix仪表板以高效的方式显示每个断路器的运行状况。</p><p><img src="http://cloud.spring.io/spring-cloud-static/Finchley.M2/images/Hystrix.png" style="zoom:30%"><em>Hystrix Dashboard</em></p><h2 id="3-Hystrix超时和Ribbon-Client"><a href="#3-Hystrix超时和Ribbon-Client" class="headerlink" title="3. Hystrix超时和Ribbon Client"></a>3. Hystrix超时和Ribbon Client</h2><p><a href="http://cloud.spring.io/spring-cloud-static/Finchley.M2/#_hystrix_timeouts_and_ribbon_clients" target="_blank" rel="noopener">原文链接</a></p><p>当使用Hystrix命令包装Ribbon client，你需要确保配置的Hystrix超时时间大于配置的Ribbon超时时间，包括任何潜在的重试。例如，如果你的ribbon连接超时是1秒，ribbon client可能重试3次，然后Hystrix超时应该略大于3秒。</p><h3 id="3-1-如何引入Hystrix-Dashboard"><a href="#3-1-如何引入Hystrix-Dashboard" class="headerlink" title="3.1 如何引入Hystrix Dashboard"></a>3.1 如何引入Hystrix Dashboard</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix-netflix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>运行Hystrix Dashboard使用<code>@EnableHystrixDashboard</code>注释Spring Boot主类。然后访问<code>/hystrix</code>并将仪表板指向Hystrix客户端应用程序中的单个实例的<code>/hystrix.stream</code>端点。</p><p><strong>提示：</strong> 连接到使用HTTPS的<code>/hystrix.stream</code>端点时，服务器使用的证书必须由JVM信任。如果证书不可信，你必须将证书导入到JVM中，以便Hystrix仪表板能成功连接到流终端。</p><h3 id="3-2-Turbine"><a href="#3-2-Turbine" class="headerlink" title="3.2 Turbine"></a>3.2 Turbine</h3><p>从单个实例来看，Hystrix数据在整个系统的健康状况方面并不是很有用。<a href="https://github.com/Netflix/Turbine" target="_blank" rel="noopener">Turbine</a>是一个应用程序，它将所有相关的<code>/hystrix.stream</code>端点汇总到一个用于Hystrix仪表板的组合<code>/turbine.stream</code>中。单个实例通过Eureka找到。运行Turbine与使用@<code>EnableTurbine</code>注释注释主类一样简单(例如，在classpath引入spring-cloud-starter-netflix-turbine)。来自<a href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x" target="_blank" rel="noopener">Turbine 1 wiki</a>)的文档配置属性都适用。唯一的区别是<code>turbine.instanceUrlSuffix</code>不需要预先添加端口，因为这是自动处理的，除非<code>turbine.instanceInsertPort=false</code>。</p><p><strong>提示：</strong> 默认情况下，Turbine在注册实例上查找<code>/hystrix.stream</code>端点是通过在Eureka中查找其<code>homePageUrl</code>条目，然后将<code>/hystrix.stream</code>附加到上面。这意味着如果<code>spring-boot-actuator</code>在自己的端口上运行（这是默认的），对<code>/hystrix.stream</code>的调用将失败。要使Turbine在正确的端口找到Hystrix流，你需要将<code>management.port</code>添加到实例的metadata：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    metadata-map:</span><br><span class="line">      management.port: $&#123;management.port:8081&#125;</span><br></pre></td></tr></table></figure><p>配置<code>turbine.appConfig</code>是Turbine用于查找实例的Eureka中注册的serviceId的列表。Turbine stream然后在Hystrix仪表板中使用一个类似如下的url：<code>http://my.turbine.sever:8080/turbine.stream?cluster=&lt;CLUSTERNAME&gt;</code>(cluster参数可以被省略，如果名称是“default”)。<code>cluster</code>参数必须与<code>turbine.aggregator.clusterConfig</code>中的条目匹配。从Eureka返回的值是大写，因此，如果有一个名为“customers”的应用程序在Eureka注册，我们预计这个例子将起作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: CUSTOMERS</span><br><span class="line">  appConfig: customers</span><br></pre></td></tr></table></figure><p><code>clusterName</code>可以通过<code>turb.clusterNameExpression</code>中的SPEL表达式来定制，指定<code>InstanceInfo</code>的一个实例。默认值是<code>appName</code>，这意味着Eureka serviceId最终作为集群key(即customers的InstanceInfo具有“CUSTOMERS”的<code>appName</code>)。另一个示例是<code>turb.clusterNameExpression=aSGName</code>，它将从AWS ASG名称获取集群名称。另一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: SYSTEM,USER</span><br><span class="line">  appConfig: customers,stores,ui,admin</span><br><span class="line">  clusterNameExpression: metadata[&apos;cluster&apos;]</span><br></pre></td></tr></table></figure><p>在这种情况下，来自4个服务的集群名称将从其metadata映射中提取出来，预期包含“SYSTEM”和“USER”的值。</p><p>要为所有应用程序使用“default”集群，你需要一个字符串文字表达式(使用单引号，如果使用YAML，则使用双引号进行转义):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">turbine:</span><br><span class="line">  appConfig: customers,stores</span><br><span class="line">  clusterNameExpression: &quot;&apos;default&apos;&quot;</span><br></pre></td></tr></table></figure><p>Spring Cloud提供了一个<code>spring-cloud-starter-netflix-turbine</code>，它拥有运行Turbine服务器所需的所有依赖。只需创建一个Spring Boot应用程序并使用<code>@EnableTurbine</code>对其进行注释。</p><p><strong>提示：</strong> 默认情况下，Spring Cloud允许Turbine使用主机和端口来允许每个主机，每个集群使用多个进程。如果你希望Turbine中内置的本机Netflix行为不允许每个主机，每个集群（实例id的key是主机名）都有多个进程，那么请设置属性<code>turbine.combineHostPort=false</code>。</p><h3 id="3-3-Turbine-Stream"><a href="#3-3-Turbine-Stream" class="headerlink" title="3.3 Turbine Stream"></a>3.3 Turbine Stream</h3><p>在某些环境下（例如在PaaS设置中），从所有分布式Hystrix命令中提取指标的传统Turbine模型不起作用。在这种情况下，你可能希望让你的Hystrix命令将度量标准推送到Turbine，Spring Cloud通过消息传递来实现。你需要在客户端上执行的操作是添加依赖关系到你选择的<code>spring-cloud-netflix-hystrix-stream</code>和<code>spring-cloud-starter-stream-*</code>(有关broker和如何配置客户端凭据的详细信息，请参阅Spring Cloud Stream文档，但它应该为本地broker开箱即用)。</p><p>在server端只需创建一个Spring Boot应用程序并使用<code>@EnableTurbineStream</code>对其进行注释，默认情况下它将在8989端口(将Hystrix仪表板指向该端口，任何路径)运行。你可以使用<code>server.port</code>或<code>turbine.stream.port</code>来自定义端口。如果在classpath中也有<code>spring-boot-starter-web</code>和<code>spring-boot-starter-actuator</code>，那么你可以通过提供一个不同的<code>management.port</code>，在单独的端口(默认情况下使用Tomcat)打开Actuator端点。</p><p>然后你可以将Hystrix仪表板指向Turbine Stream Server，而不是单独的Hystrix流。如果Turbine Stream在myhost上的8989端口上运行，则将http:// myhost:8989放在Hystrix仪表板的流输入字段中。电路将以它们各自的serviceId为前缀，接着是一个点，然后是电路名称。</p><p>Spring Cloud提供了一个<code>spring-cloud-starter-netflix-turbine-stream</code>，它拥有运行Turbine Stream server所需的所有依赖关系，只需添加你选择的Stream绑定程序，例如：<code>spring-cloud-starter-stream-rabbit</code>。你需要Java 8来运行应用程序，因为它是基于Netty的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Hystrix-Clients&quot;&gt;&lt;a href=&quot;#1-Hystrix-Clients&quot; class=&quot;headerlink&quot; title=&quot;1. Hystrix Clients&quot;&gt;&lt;/a&gt;1. Hystrix Clients&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Finchley.M2/#_circuit_breaker_hystrix_clients&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Netflix创建了一个实现了&lt;a href=&quot;https://martinfowler.com/bliki/CircuitBreaker.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;circuit breaker模式&lt;/a&gt;的叫做&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hystrix&lt;/a&gt;的库。在一个微服务架构中通常有多层的服务调用，如下图。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>客户端侧的负载均衡--Ribbon</title>
    <link href="https://maoyunfei.github.io/spring/d662598d/"/>
    <id>https://maoyunfei.github.io/spring/d662598d/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.763Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#spring-cloud-ribbon" target="_blank" rel="noopener">原文链接</a></p><p>Ribbon是一个客户端负载均衡器，它可以让您对HTTP和TCP客户端的行为有很大的控制权。 Feign已经使用Ribbon，所以如果您使用的是@FeignClient，那么这个部分也适用。</p><p>Ribbon中一个重要的概念是named client。Spring Cloud使用RibbonClientConfiguration根据需要为每个named client创建一个新的集合作为ApplicationContext，这包含（除其他外）ILoadBalancer，RestClient和ServerListFilter。<br><a id="more"></a></p><h2 id="1-如何引入Ribbon"><a href="#1-如何引入Ribbon" class="headerlink" title="1. 如何引入Ribbon"></a>1. 如何引入Ribbon</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-自定义Ribbon-Client"><a href="#2-自定义Ribbon-Client" class="headerlink" title="2. 自定义Ribbon Client"></a>2. 自定义Ribbon Client</h2><p>你可以使用<code>&lt;client&gt;.ribbon.*</code>属性来配置ribbon client。</p><p>Spring Cloud还允许你通过使用<code>@RibbonClient</code>声明其他配置（在<code>RibbonClientConfiguration</code>上）来完全控制客户端。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RibbonClient(name = &quot;foo&quot;, configuration = FooConfiguration.class)</span><br><span class="line">public class TestConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，ribbon client由已经在<code>RibbonClientConfiguration</code>中的组件和<code>FooConfiguration</code>中的任何组件（后者通常会覆盖前者）组成。(备注：使用<code>RibbonClientConfiguration</code>中的Bean和自定义的<code>FooConfiguration</code>中的Bean来配置ribbon client, <code>FooConfiguration</code>中的Bean会覆盖<code>RibbonClientConfiguration</code>中的Bean)</p><p><strong>注意：</strong> 上面的<code>FooConfiguration</code>必须用<code>@Configuration</code>，但是注意它不能在应用上下文被<code>@ComponentScan</code>扫描到，否则它将被所有<code>@RibbonClient</code>所共享。如果你使用<code>@ComponentScan</code>或者<code>@SpringBootApplication</code>,你需要避免它被包括在内(例如：把它放在一个单独的，不重叠的包或者在<code>@ComponentScan</code>中明确指定要扫描的包)。(备注：我是在<code>src/main/java</code>下新建一个package,将自定义的RibbonConfiguration配置Bean放在这个包下)</p><h3 id="Spring-Cloud-Netflix默认给ribbon提供以下的bean-BeanType-beanName-ClassName"><a href="#Spring-Cloud-Netflix默认给ribbon提供以下的bean-BeanType-beanName-ClassName" class="headerlink" title="Spring Cloud Netflix默认给ribbon提供以下的bean(BeanType beanName: ClassName):"></a>Spring Cloud Netflix默认给ribbon提供以下的bean(<code>BeanType</code> beanName: <code>ClassName</code>):</h3><ul><li><code>IClientConfig</code> ribbonClientConfig: <code>DefaultClientConfigImpl</code></li><li><code>IRule</code> ribbonRule: <code>ZoneAvoidanceRule</code></li><li><code>IPing</code> ribbonPing: <code>NoOpPing</code></li><li><code>ServerList&lt;Server&gt;</code> ribbonServerList: <code>ConfigurationBasedServerList</code></li><li><code>ServerListFilter&lt;Server&gt;</code> ribbonServerListFilter: <code>ZonePreferenceServerListFilter</code></li><li><code>ILoadBalancer</code> ribbonLoadBalancer: <code>ZoneAwareLoadBalancer</code></li><li><code>ServerListUpdater</code> ribbonServerListUpdater: <code>PollingServerListUpdater</code></li></ul><p>创建这些类型的bean并将其放置在<code>@RibbonClient</code>配置Bean（例如上面的<code>FooConfiguration</code>）中，可以覆盖所描述的每个bean。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FooConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public IPing ribbonPing(IClientConfig config) &#123;</span><br><span class="line">        return new PingUrl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将用<code>PingUrl</code>代替<code>NoOpPing</code>。</p><h2 id="3-使用properties来自定义Ribbon-Client"><a href="#3-使用properties来自定义Ribbon-Client" class="headerlink" title="3. 使用properties来自定义Ribbon Client"></a>3. 使用properties来自定义Ribbon Client</h2><p>Spring Cloud Netflix现在支持使用properties来定制Ribbon client，以便与<a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer" target="_blank" rel="noopener">Ribbon文档</a>兼容。</p><p>这使你可以在不同的环境启动时更改行为。</p><p>支持的属性如下所列，并应以<code>&lt;clientName&gt;.ribbon</code>为前缀：</p><ul><li><code>NFLoadBalancerClassName</code>: should implement <code>ILoadBalancer</code></li><li><code>NFLoadBalancerRuleClassName</code>: should implement <code>IRule</code></li><li><code>NFLoadBalancerPingClassName</code>: should implement <code>IPing</code></li><li><code>NIWSServerListClassName</code>: should implement <code>ServerList</code></li><li><code>NIWSServerListFilterClassName</code>: should implement <code>ServerListFilter</code></li></ul><p><strong>提示：</strong> 在这些属性中定义的类优先于使用<code>@RibbonClient(configuration=MyRibbonConfig.class)</code>定义的bean和Spring Cloud Netflix提供的默认类。</p><p>要为一个名为<code>users</code>的服务设置<code>IRule</code>，可以如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">users:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</span><br></pre></td></tr></table></figure><h2 id="4-Ribbon和Eureka一起使用"><a href="#4-Ribbon和Eureka一起使用" class="headerlink" title="4. Ribbon和Eureka一起使用"></a>4. Ribbon和Eureka一起使用</h2><p>当Eureka和Ribbon一起使用(例如，二者都在classpath), <code>ribbonServerList</code>被<code>DiscoveryEnabledNIWSServerList</code>的一个扩展覆盖了，该扩展的server list来自于Eureka。同时用<code>NIWSDiscoveryPing</code>替代<code>IPing</code>,通过Eureka来判断服务状态是否为UP。默认安装的ServerList是一个DomainExtractingServerList，这样做的目的是在不使用AWS AMI metadata(这是Netflix所依赖的)的情况下为负载均衡器提供物理metadata。默认情况下，server list将使用实例metadata中提供的“zone”信息构建（所以在远程客户端上设置<code>eureka.instance.metadataMap.zone</code>）,如果没有设置zone，可以使用服务器hostname的域名作为zone的代理（如果设置了标志<code>approximateZoneFromHostname</code>）。一旦zone信息可用，就可以在<code>ServerListFilter</code>中使用。默认情况下，它将用于定位与client位于同一个zone的server，因为默认值是<code>ZonePreferenceServerListFilter</code>。默认地client的zone的确定方式与远程实例相同，即通过<code>eureka.instance.metadataMap.zone</code>。</p><p><strong>提示：</strong> 如果没有设置zone数据，则根据client配置（而不是实例配置）进行猜测。我们把<code>eureka.client.availabilityZones</code>(这是一个从region名称到zone列表的map)，并取出实例所在region的第一个zone（即<code>eureka.client.region</code>，默认为“us-east-1“，为了与本地Netflix的兼容性）。</p><h2 id="5-Ribbon不和Eureka一起使用"><a href="#5-Ribbon不和Eureka一起使用" class="headerlink" title="5. Ribbon不和Eureka一起使用"></a>5. Ribbon不和Eureka一起使用</h2><p>Eureka是一个远程服务发现的一个简便实现，所以你不需要在client端硬编码url，但是如果你不喜欢使用eureka，Ribbon和Feign仍然很合适。假设你已经为“stores”声明了@RibbonClient, 并且没有使用eureka。Ribbon client默认使用一个配置的server list,你可以像这样提供配置：</p><p><strong>application.yml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stores:</span><br><span class="line">  ribbon:</span><br><span class="line">    listOfServers: example.com,google.com</span><br></pre></td></tr></table></figure><h2 id="6-在Ribbon中禁用Eureka"><a href="#6-在Ribbon中禁用Eureka" class="headerlink" title="6. 在Ribbon中禁用Eureka"></a>6. 在Ribbon中禁用Eureka</h2><p>设置属性<code>ribbon.eureka.enabled = false</code>将明确禁止在Ribbon中使用Eureka。</p><p><strong>application.yml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eureka:</span><br><span class="line">   enabled: false</span><br></pre></td></tr></table></figure><h2 id="7-直接使用Ribbon-API"><a href="#7-直接使用Ribbon-API" class="headerlink" title="7. 直接使用Ribbon API"></a>7. 直接使用Ribbon API</h2><p>你可以直接使用<code>LoadBalancerClient</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    public void doStuff() &#123;</span><br><span class="line">        ServiceInstance instance = loadBalancer.choose(&quot;stores&quot;);</span><br><span class="line">        URI storesUri = URI.create(String.format(&quot;http://%s:%s&quot;, instance.getHost(), instance.getPort()));</span><br><span class="line">        // ... do something with the URI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Ribbon的缓存配置"><a href="#8-Ribbon的缓存配置" class="headerlink" title="8. Ribbon的缓存配置"></a>8. Ribbon的缓存配置</h2><p>每个named client的Ribbon都有一个Spring Cloud维护的对应子应用程序上下文,这个应用程序的上下文是当对named client第一次请求时懒加载的。可以将此延迟加载行为更改为在启动时立即加载这些子应用程序上下文，通过指定Ribbon client的名称来配置。</p><p><strong>application.yml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: client1, client2, client3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#spring-cloud-ribbon&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Ribbon是一个客户端负载均衡器，它可以让您对HTTP和TCP客户端的行为有很大的控制权。 Feign已经使用Ribbon，所以如果您使用的是@FeignClient，那么这个部分也适用。&lt;/p&gt;&lt;p&gt;Ribbon中一个重要的概念是named client。Spring Cloud使用RibbonClientConfiguration根据需要为每个named client创建一个新的集合作为ApplicationContext，这包含（除其他外）ILoadBalancer，RestClient和ServerListFilter。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Declarative REST Client--Feign</title>
    <link href="https://maoyunfei.github.io/spring/2db5c206/"/>
    <id>https://maoyunfei.github.io/spring/2db5c206/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.764Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#spring-cloud-feign" target="_blank" rel="noopener">原文链接</a></p><p>Feign是一个声明式的web服务client。它让编写web服务客户端更简单。使用Feign需要创建一个接口并在上面加注解。它有可插拔的注解支持，包括Feign的注解和JAX-RS的注解。Feign也支持可插拔式的编码器(encoder)和解码器(decoder)。Spring Cloud增加了对Spring MVC注解的支持，并且使用了Spring Web中默认使用的<code>HttpMessageConverters</code>。Spring Cloud整合Ribbon和Eureka，在使用Feign时提供负载均衡的http client。<br><a id="more"></a></p><h2 id="1-1-如何引入Feign"><a href="#1-1-如何引入Feign" class="headerlink" title="1.1 如何引入Feign"></a>1.1 如何引入Feign</h2><p><em>pom.xml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><em>Application.java</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>StoreClient.java</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(&quot;stores&quot;)</span><br><span class="line">public interface StoreClient &#123;</span><br><span class="line">    @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span><br><span class="line">    List&lt;Store&gt; getStores();</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;)</span><br><span class="line">    Store update(@PathVariable(&quot;storeId&quot;) Long storeId, Store store);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@FeignClient注解中的值“stores”是一个任意client name,被用来创建一个Ribbon负载均衡器。你也可以使用<code>url</code>属性来指定一个URL。在application context中的bean名称是这个接口的全限定名。你可以使用<code>@FeignClient</code>注解的<code>qualifier</code><br>属性来指定你自己的别名。</p><p>上面的Ribbon client会去获取“stores”服务的物理地址。如果你的应用是一个Eureka client，它将解析在Eureka server注册的服务。如果你不想使用Eureka, 你可以在你的配置文件中额外配置一个服务列表。</p><h1 id="1-2-覆盖Feign默认配置"><a href="#1-2-覆盖Feign默认配置" class="headerlink" title="1.2 覆盖Feign默认配置"></a>1.2 覆盖Feign默认配置</h1><p>Spring Cloud Feign支持的一个重要概念是named client。每个Feign client都是集合的一部分，它们一起工作来连接远程服务.作为应用开发者，你使用<code>@FeignClient</code>注解来给这个集合一个名字。Spring Cloud使用<code>FeignClientsConfiguration</code>创建一个新的集合，作为每个指定客户端的<code>ApplicationContext</code>。这包括<code>feign.Decoder</code>,<code>feign.Encoder</code>,<code>feign.Contract</code>等。</p><p>通过使用<code>@FeignClient</code>声明额外的配置（在<code>FeignClientsConfiguration之</code>上），Spring Cloud可让你完全控制Ribbon client。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)</span><br><span class="line">public interface StoreClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，ribbon client由已经在FeignClientsConfiguration中的组件和FooConfiguration中的任何组件（后者将覆盖前者）组成。</p><p><strong>提示：</strong> <code>FooConfiguration</code>不需要<code>@Configuraion</code>注解。(备注：这一点和ribbon client完全相反，<a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_customizing_the_ribbon_client" target="_blank" rel="noopener"><code>@RibbonClient</code>的configuration必须被<code>@Configuration</code>注解</a>。)<br>它不能在应用上下文被<code>@ComponentScan</code>扫描到，否则它将被所有<code>@FeignClient</code>所共享。(备注：在这个特性上，和<code>RibbonClient</code>一样)</p><p><code>name</code>和<code>url</code>属性支持占位符,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;$&#123;feign.name&#125;&quot;, url = &quot;$&#123;feign.url&#125;&quot;)</span><br><span class="line">public interface StoreClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Cloud Netflix默认提供以下bean (<code>BeanType</code> beanName：<code>ClassName</code>):</p><ul><li><code>Decoder</code> feignDecoder: <code>ResponseEntityDecoder</code>(封装的<code>SpringDecoder</code>)</li><li><code>Encoder</code> feignEncoder: <code>SpringEncoder</code></li><li><code>Logger</code> feignLogger: <code>Slf4jLogger</code></li><li><code>Contract</code> feignContract: <code>SpringMvcContract</code></li><li><code>Feign.Builder</code> feignBuilder: <code>HystrixFeign.Builder</code></li><li><code>Client</code> feignClient: 如果ribbon开启是<code>LoadBalancerFeignClient</code>, 否则是默认的feign client。</li></ul><p>通过设置<code>feign.okhttp.enabled</code>或<code>feign.httpclient.enabled</code>为<code>true</code>，可以使用<code>OkHttpClient</code>和<code>ApacheHttpClient</code>的feign client，并将它们放到classpath。</p><p>Spring Cloud Netflix默认情况下不提供以下bean，但仍从应用程序上下文中查找这些类型的bean以创建feign client：</p><ul><li><code>Logger.Level</code></li><li><code>Retryer</code></li><li><code>ErrorDecoder</code></li><li><code>Request.Options</code></li><li><code>Collection&lt;RequestInterceptor&gt;</code></li><li><code>SetterFactory</code></li></ul><p>创建这些类型的bean并将其放入@FeignClient配置（例如上面的FooConfiguration）就能够覆盖所描述的每个bean。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FooConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Contract feignContract() &#123;</span><br><span class="line">        return new feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() &#123;</span><br><span class="line">        return new BasicAuthRequestInterceptor(&quot;user&quot;, &quot;password&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这用<code>feign.Contract.Default</code>代替了<code>SpringMvcContract</code>，并且将一个<code>RequestInterceptor</code>添加到<code>RequestInterceptor</code>的集合中。</p><p><code>@FeignClient</code>也可以使用配置属性进行配置。</p><p><em>application.yml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      feignName:</span><br><span class="line">        connectTimeout: 5000</span><br><span class="line">        readTimeout: 5000</span><br><span class="line">        loggerLevel: full</span><br><span class="line">        errorDecoder: com.example.SimpleErrorDecoder</span><br><span class="line">        retryer: com.example.SimpleRetryer</span><br><span class="line">        requestInterceptors:</span><br><span class="line">          - com.example.FooRequestInterceptor</span><br><span class="line">          - com.example.BarRequestInterceptor</span><br><span class="line">        decode404: false</span><br></pre></td></tr></table></figure><p>默认配置可以在<code>@EnableFeignClients</code>属性<code>defaultConfiguration</code>中以与上述类似的方式指定。不同的是，这个配置将适用于所有的feign client。</p><p>如果你更喜欢使用配置属性来配置所有<code>@FeignClient</code>，则可以使用<code>default</code>这个feign名称来创建配置属性。</p><p><em>application.yml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default:</span><br><span class="line">        connectTimeout: 5000</span><br><span class="line">        readTimeout: 5000</span><br><span class="line">        loggerLevel: basic</span><br></pre></td></tr></table></figure><p>如果我们同时创建<code>@Configuration</code> bean和配置属性，配置属性将会胜出。它将覆盖<code>@Configuration</code>的值。但是如果你想改变<code>@Configuration</code>的优先级，你可以把<code>feign.client.default-to-properties</code>设为<code>false</code>。</p><p><strong>提示：</strong> 如果你需要在你的<code>RequestInterceptor</code>中使用<code>ThreadLocal</code>域变量，你要么把Hystrix的<code>thread isolation strategy</code>设为<code>SEMAPHORE</code>，要么在Feign中禁用Hystrix。</p><p><em>application.yml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># To disable Hystrix in Feign</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line"># To set thread isolation to SEMAPHORE</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: SEMAPHORE</span><br></pre></td></tr></table></figure><h2 id="1-3-手动创建Feign-Client"><a href="#1-3-手动创建Feign-Client" class="headerlink" title="1.3 手动创建Feign Client"></a>1.3 手动创建Feign Client</h2><p>在某些情况下，可能需要在不方便使用以上方法的时自定义你的Feign Client。在这种情况下，你可以使用<a href="https://github.com/OpenFeign/feign/#basics" target="_blank" rel="noopener">Feign Builder API</a>创建client。下面是一个例子，它创建两个具有相同接口的Feign client，但用每个客户端配置了一个单独的请求拦截器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Import(FeignClientsConfiguration.class)</span><br><span class="line">class FooController &#123;</span><br><span class="line"></span><br><span class="line">private FooClient fooClient;</span><br><span class="line"></span><br><span class="line">private FooClient adminClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">public FooController(</span><br><span class="line">Decoder decoder, Encoder encoder, Client client) &#123;</span><br><span class="line">this.fooClient = Feign.builder().client(client)</span><br><span class="line">.encoder(encoder)</span><br><span class="line">.decoder(decoder)</span><br><span class="line">.requestInterceptor(new BasicAuthRequestInterceptor(&quot;user&quot;, &quot;user&quot;))</span><br><span class="line">.target(FooClient.class, &quot;http://PROD-SVC&quot;);</span><br><span class="line">this.adminClient = Feign.builder().client(client)</span><br><span class="line">.encoder(encoder)</span><br><span class="line">.decoder(decoder)</span><br><span class="line">.requestInterceptor(new BasicAuthRequestInterceptor(&quot;admin&quot;, &quot;admin&quot;))</span><br><span class="line">.target(FooClient.class, &quot;http://PROD-SVC&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong> 在上面的例子中，<code>FeignClientsConfiguration.class</code>是由Spring Cloud Netflix提供的默认配置。<code>PROD-SVC</code>是client要请求的服务的名称。</p><h2 id="1-4-Feign的Hystrix支持"><a href="#1-4-Feign的Hystrix支持" class="headerlink" title="1.4 Feign的Hystrix支持"></a>1.4 Feign的Hystrix支持</h2><p>如果Hystrix在classpath上并且<code>feign.hystrix.enabled=true</code>,那么Feign将用一个断路器来包装所有的方法。返回一个<code>com.netflix.hystrix.HystrixCommand</code>也是可以的。这将让你使用响应式模式(调用<code>.toObservable()</code>或<code>.observe()</code>或异步使用（调用<code>.queue()</code>)</p><p>要基于每个client禁用Hystrix支持，需要创建一个具有“prototype”范围的<code>Feign.Builder</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FooConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public Feign.Builder feignBuilder() &#123;</span><br><span class="line">return Feign.builder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>警告：</strong> 在Spring Cloud Dalston发布之前，如果Hystrix在classpath上(备注：pom.xml中有spring-cloud-starter-hystrix依赖)，Feign默认情况下会将所有方法封装在断路器中。 Spring Cloud Dalston改变了这种默认行为，赞成采用选择加入的方式。(备注：Dalston前的版本中 feign.hystrix.enabled 默认值为true，Dalston及其之后的版本中 feign.hystrix.enabled 默认值为false)</p><h2 id="1-5-Feign-Hystrix-Fallbacks"><a href="#1-5-Feign-Hystrix-Fallbacks" class="headerlink" title="1.5 Feign Hystrix Fallbacks"></a>1.5 Feign Hystrix Fallbacks</h2><p>Hystrix支持fallback的概念：一个默认的代码路径，在断路或出现错误时执行。为给定的<code>@FeignClient</code>启用fallback功能，将<code>fallback</code>属性设置为实现fallback的类名称。你还需要将你的实现声明为Spring bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;hello&quot;, fallback = HystrixClientFallback.class)</span><br><span class="line">protected interface HystrixClient &#123;</span><br><span class="line">    @RequestMapping(method = RequestMethod.GET, value = &quot;/hello&quot;)</span><br><span class="line">    Hello iFailSometimes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class HystrixClientFallback implements HystrixClient &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Hello iFailSometimes() &#123;</span><br><span class="line">        return new Hello(&quot;fallback&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要访问fallback触发的原因，则可以使用<code>@FeignClient</code>中的<code>fallbackFactory</code>属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;hello&quot;, fallbackFactory = HystrixClientFallbackFactory.class)</span><br><span class="line">protected interface HystrixClient &#123;</span><br><span class="line">@RequestMapping(method = RequestMethod.GET, value = &quot;/hello&quot;)</span><br><span class="line">Hello iFailSometimes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">static class HystrixClientFallbackFactory implements FallbackFactory&lt;HystrixClient&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public HystrixClient create(Throwable cause) &#123;</span><br><span class="line">return new HystrixClientWithFallBackFactory() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Hello iFailSometimes() &#123;</span><br><span class="line">return new Hello(&quot;fallback; reason was: &quot; + cause.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>警告：</strong> Feign的fallback和Hystrix的fallback工作有一个限制。fallback当前不支持返回类型为<code>com.netflix.hystrix.HystrixCommand</code>和<code>rx.Observable</code>的方法。</p><h2 id="1-6-Feign和-Primary"><a href="#1-6-Feign和-Primary" class="headerlink" title="1.6 Feign和@Primary"></a>1.6 Feign和@Primary</h2><p>当使用Feign的Hystrix fallback时，ApplicationContext中有多个同一类型的Bean。这将会导致@Autowired不工作，因为没有一个确切的bean或者一个标记为primary的。要解决这个问题，Spring Cloud Netflix让所有的Feign实例为<code>@Primary</code>，所以Spring Framework将知道注入哪个bean。在一些情况下，这可能是不可取的。要关闭这个特性，设置<code>@FeignClient</code>的<code>primary</code>属性为<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;hello&quot;, primary = false)</span><br><span class="line">public interface HelloClient &#123;</span><br><span class="line">// methods here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-Feign的继承支持"><a href="#1-7-Feign的继承支持" class="headerlink" title="1.7 Feign的继承支持"></a>1.7 Feign的继承支持</h2><p>Feign通过单继承接口支持样板apis。这允许将通用操作分组为方便的基础接口。</p><p><em>UserService.java</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span><br><span class="line">    User getUser(@PathVariable(&quot;id&quot;) long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>UserResource.java</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserResource implements UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserClient.java<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package project.user;</span><br><span class="line"></span><br><span class="line">@FeignClient(&quot;users&quot;)</span><br><span class="line">public interface UserClient extends UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>提示：</strong> 一般不建议在server和client之间共享一个接口。它引入了紧密的耦合，而且实际上以当前的形式用于Spring MVC并不起作用（方法参数映射不被继承）。</p><h2 id="1-8-Feign请求响应的压缩"><a href="#1-8-Feign请求响应的压缩" class="headerlink" title="1.8 Feign请求响应的压缩"></a>1.8 Feign请求响应的压缩</h2><p>你可以考虑为你的Feign请求开启请求或响应的GZIP压缩。你可以通过开启以下属性来完成此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eign.compression.request.enabled=true</span><br><span class="line">feign.compression.response.enabled=true</span><br></pre></td></tr></table></figure><p>Feign请求压缩为你提供了类似于设置Web服务器的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign.compression.request.enabled=true</span><br><span class="line">feign.compression.request.mime-types=text/xml,application/xml,application/json</span><br><span class="line">feign.compression.request.min-request-size=2048</span><br></pre></td></tr></table></figure><p>这些属性允许你选择压缩的media type和最小请求阈值长度。</p><h2 id="1-9-Feign日志"><a href="#1-9-Feign日志" class="headerlink" title="1.9 Feign日志"></a>1.9 Feign日志</h2><p>为每一个Feign client创建一个logger，logger默认的名字是用来创建Feign client的接口的全限定类名。Feign的日志只响应<code>DEBUG</code>级别。</p><p><em>application.yml</em></p><p><code>logging.level.project.user.UserClient: DEBUG</code></p><p>你可以为每一个client配置一个<code>Logger.Level</code>对象，告诉Feign去记录什么。有以下选择：</p><ul><li><p><code>NONE</code>, 不记录 (默认).</p></li><li><p><code>BASIC</code>, 只记录请求方法、URL、响应状态码和执行时间。</p></li><li><p><code>HEADERS</code>, 记录请求头和响应头的基本信息。</p></li><li><p><code>FULL</code>, 记录请求和响应的headers、body和metadata。</p></li></ul><p>例如：以下将设置<code>Logger.Level</code>设为<code>FULL</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FooConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    Logger.Level feignLoggerLevel() &#123;</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#spring-cloud-feign&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Feign是一个声明式的web服务client。它让编写web服务客户端更简单。使用Feign需要创建一个接口并在上面加注解。它有可插拔的注解支持，包括Feign的注解和JAX-RS的注解。Feign也支持可插拔式的编码器(encoder)和解码器(decoder)。Spring Cloud增加了对Spring MVC注解的支持，并且使用了Spring Web中默认使用的&lt;code&gt;HttpMessageConverters&lt;/code&gt;。Spring Cloud整合Ribbon和Eureka，在使用Feign时提供负载均衡的http client。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>具有负载均衡功能的RestTemplate</title>
    <link href="https://maoyunfei.github.io/spring/96993ac3/"/>
    <id>https://maoyunfei.github.io/spring/96993ac3/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_spring_resttemplate_as_a_load_balancer_client" target="_blank" rel="noopener">原文链接</a></p><p>通过@LoadBalanced和@Bean修饰可以生成一个具有负载均衡功能的RestTemplate。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Bean</span><br><span class="line">    RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>提示：</strong> 从Spring Boot 1.4开始不再提供自动配置的RestTemplate Bean,你必须自己创建。</p><h2 id="Retrying-Failed-Requests"><a href="#Retrying-Failed-Requests" class="headerlink" title="Retrying Failed Requests"></a>Retrying Failed Requests</h2><p>RestTemplatede的失败重试,默认是不可用的，如果需要开启，需要设置<code>spring.cloud.loadbalancer.retry.enabled=true</code>并且添加Spring Retry依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>具有负载均衡功能的RestTemplate将遵循Ribbon关于重试的配置，如<code>client.ribbon.MaxAutoRetries</code>，<code>client.ribbon.MaxAutoRetriesNextServer</code>，<code>client.ribbon.OkToRetryOnAllOperations</code>。<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties" target="_blank" rel="noopener">Ribbon具体的配置</a>。</p><h1 id="Multiple-RestTemplate-objects"><a href="#Multiple-RestTemplate-objects" class="headerlink" title="Multiple RestTemplate objects"></a>Multiple RestTemplate objects</h1><p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_multiple_resttemplate_objects" target="_blank" rel="noopener">原文链接</a></p><p>如果需要同时使用具有负载均衡功能和普通的RestTemplate，可以如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Bean</span><br><span class="line">    RestTemplate loadBalanced() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean</span><br><span class="line">    RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    private RestTemplate loadBalanced;</span><br><span class="line"></span><br><span class="line">    public String doOtherStuff() &#123;</span><br><span class="line">        return loadBalanced.getForObject(&quot;http://stores/stores&quot;, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String doStuff() &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http://example.com&quot;, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RestTemplate bean上的@Primary注解表明当@Autowired时没有特殊修饰符时使用该实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_spring_resttemplate_as_a_load_balancer_client&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;通过@LoadBalanced和@Bean修饰可以生成一个具有负载均衡功能的RestTemplate。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class MyConfiguration &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @LoadBalanced&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Bean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RestTemplate restTemplate() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return new RestTemplate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>服务发现--Netflix Eureka</title>
    <link href="https://maoyunfei.github.io/spring/6213b905/"/>
    <id>https://maoyunfei.github.io/spring/6213b905/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2018-03-04T11:51:48.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eureka-Clients"><a href="#Eureka-Clients" class="headerlink" title="Eureka Clients"></a><span id="1.1">Eureka Clients</span></h2><p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_service_discovery_eureka_clients" target="_blank" rel="noopener">原文链接</a></p><h3 id="如何引入Eureka-Client"><a href="#如何引入Eureka-Client" class="headerlink" title="如何引入Eureka Client"></a>如何引入Eureka Client</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="注册到Eurake"><a href="#注册到Eurake" class="headerlink" title="注册到Eurake"></a>注册到Eurake</h3><p>当一个client注册到Eureka，它提供自己的meta-data，例如host,port,health indicator URL,home page等。Eureka接受心跳信息从属于一个服务的每个实例。如果心跳在一个配置的时间内失败，实例将从注册中心移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><ul><li>Authenticating with the Eureka Server</li></ul><p>在</p><figure class="highlight plain"><figcaption><span>URLs中加上认证信息，如```http://user:password@localhost:8761/eureka```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* Why is it so Slow to Register a Service?</span><br><span class="line"></span><br><span class="line">一个实例涉及和注册中心的周期性的心跳，默认周期为30s。一个服务不被客户端发现直到实例，服务端和客户端都在它们本地缓存有了相同的metadata。你可以用```eureka.instance.leaseRenewalIntervalInSeconds```来改变周期，这会加速client和其他server的连接进程。在生产环境最好遵守默认配置，因为在server有一些关于续约周期的内部计算。</span><br><span class="line"></span><br><span class="line">## &lt;span id=&quot;1.2&quot;&gt;Eureka Server</span><br><span class="line">[原文链接](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#spring-cloud-eureka-server)</span><br><span class="line"></span><br><span class="line">### 如何引入Eureka Server</span><br></pre></td></tr></table></figure><p></p><p><dependency><br><groupid>org.springframework.cloud</groupid><br><artifactid>spring-cloud-starter-eureka-server</artifactid><br></dependency><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 如何运行一个Eureka Server</span><br></pre></td></tr></table></figure><p></p><p>@SpringBootApplication<br>@EnableEurekaServer<br>public class Application {</p><pre><code>public static void main(String[] args) {    new SpringApplicationBuilder(Application.class).web(true).run(args);}</code></pre><p>}<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Eureka Server有一个UI主页来查看注册的服务信息，```/eureka/```。</span><br><span class="line"></span><br><span class="line">### Standalone Mode</span><br><span class="line">在单机模式下，更喜欢关闭client端的行为，如`registerWithEureka`，`fetchRegistry`，所以它不会试图去到达它的peers。</span><br><span class="line"></span><br><span class="line">*application.yml (Standalone Eureka Server)*</span><br></pre></td></tr></table></figure><p></p><p>server:<br>port: 8761</p><p>eureka:<br>instance:<br>hostname: localhost<br>client:<br>registerWithEureka: false<br>fetchRegistry: false<br>serviceUrl:<br>defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意`serverUrl`指向本地实例的host。</span><br><span class="line"></span><br><span class="line">### Peer Awareness</span><br><span class="line">Eureka可以变得高可用通过运行多个实例并让它们相互注册。事实上，这是默认的行为，所以我们只需要给peer添加一个有效的`serviceUrl`。</span><br><span class="line"></span><br><span class="line">*application.yml (Two Peer Aware Eureka Servers)*</span><br></pre></td></tr></table></figure><p></p><hr><p>spring:<br>profiles: peer1<br>eureka:<br>instance:<br>hostname: peer1<br>client:<br>serviceUrl:<br>defaultZone: <a href="http://peer2/eureka/" target="_blank" rel="noopener">http://peer2/eureka/</a></p><hr><p>spring:<br>profiles: peer2<br>eureka:<br>instance:<br>hostname: peer2<br>client:<br>serviceUrl:<br>defaultZone: <a href="http://peer1/eureka/" target="_blank" rel="noopener">http://peer1/eureka/</a><br><code>`</code><br>你可以添加多个peers到一个系统，只要它们互相至少有一边连接，它们将互相同步注册信息。如果peers存在物理分区，该系统原则上可能存在裂脑问题。</p><h3 id="Prefer-IP-Address"><a href="#Prefer-IP-Address" class="headerlink" title="Prefer IP Address"></a>Prefer IP Address</h3><p>通常，Eureka更喜欢暴露它的IP地址而不是它的hostname，设置<code>eureka.instance.preferIpAddress</code>为<code>true</code>,当注册时，它将使用它的IP地址而不是hostname。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Eureka-Clients&quot;&gt;&lt;a href=&quot;#Eureka-Clients&quot; class=&quot;headerlink&quot; title=&quot;Eureka Clients&quot;&gt;&lt;/a&gt;&lt;span id=&quot;1.1&quot;&gt;Eureka Clients&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_service_discovery_eureka_clients&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;如何引入Eureka-Client&quot;&gt;&lt;a href=&quot;#如何引入Eureka-Client&quot; class=&quot;headerlink&quot; title=&quot;如何引入Eureka Client&quot;&gt;&lt;/a&gt;如何引入Eureka Client&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maoyunfei.github.io/categories/spring/"/>
    
    
      <category term="Spring Cloud" scheme="https://maoyunfei.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
</feed>
