<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lovexue.xyz/"/>
  <updated>2018-03-26T11:59:21.000Z</updated>
  <id>http://www.lovexue.xyz/</id>
  
  <author>
    <name>云逸云飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker端口映射与容器互联</title>
    <link href="http://www.lovexue.xyz/docker/ef9116e4/"/>
    <id>http://www.lovexue.xyz/docker/ef9116e4/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-03-26T11:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>除了通过网络访问外，Docker还提供了两个很方便的功能来满足服务访问的基本需求：</p><ul><li>一个是允许映射容器内应用的服务端口到本地宿主主机；</li><li>另一个是互联机制实现多个容器间通过容器名来快速访问。</li></ul><h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="从外部访问容器应用"><a href="#从外部访问容器应用" class="headerlink" title="从外部访问容器应用"></a>从外部访问容器应用</h3><p>在启动容器时，如果不指定对应的参数，在容器外是无法通过网络访问容器内的网络应用和服务的。</p><p>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过<code>-P</code>或<code>-p</code>参数来指定端口映射。当使用<code>-P</code>(大写)标记时，Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口。</p><p><code>-p</code>(小写)可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<code>IP:HostPort:ContainerPort</code> | <code>IP::ContainerPort</code> | <code>HostPort:ContainerPort</code>。<br><a id="more"></a></p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用<code>HostPort:ContainerPort</code>默认会绑定所有接口上的所有地址，多次使用<code>-p</code>标记可以绑定多个端口。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -p 5000:5000 -p 3000:80 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用<code>IP:HostPort:ContainerPort</code>格式指定映射使用一个特定地址。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>可以使用<code>IP::ContainerPort</code>格式绑定指定地址任意端口到容器端口，本地主机会自动分配一个端口。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用<code>docker port</code>命令可以查看当前映射的端口配置，也可以查看到绑定的地址：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port nostalgic_morse <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 容器有自己的内部网络和IP地址，使用<code>docker inspect + 容器ID</code>可以获取容器的具体信息。</p><h2 id="互联网机制实现便捷互访"><a href="#互联网机制实现便捷互访" class="headerlink" title="互联网机制实现便捷互访"></a>互联网机制实现便捷互访</h2><p>容器的互联是一种让多个容器中应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址。</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>连接系统依据容器的名称来执行，因此首先需要定义一个好记的容器名，虽然创建容器时系统会默认分配一个名字。</p><p>使用<code>--name</code>标记可以为容器自定义命名：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -P --name web training/webapp python app.py</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 容器的名称是唯一的。如果已经命名了一个叫web的容器，当要再次使用web这个名称的时候，需要先用docker rm来删除之前创建的同名容器。</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用<code>--link</code>参数可以让容器之间安全地进行交互。</p><p><code>--link</code>参数的格式为<code>--link name:alias</code>，其中<code>name</code>是要连接的容器名称，<code>alias</code>是这个连接的别名。</p><p>新建一个web容器，并将它连接到db容器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure><p>使用docker ps可以看到db容器的names列有db，也有web/db，这表示web容器连接到db容器，这允许web容器访问db容器的信息。</p><p><strong>Docker相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射它们的端口到宿主机上。</strong></p><h3 id="docker通过两种方式来为容器公开连接信息"><a href="#docker通过两种方式来为容器公开连接信息" class="headerlink" title="docker通过两种方式来为容器公开连接信息"></a>docker通过两种方式来为容器公开连接信息</h3><ul><li>更新环境变量</li><li>更新<code>/etc/hosts</code>文件</li></ul><p>使用<code>env</code>命令来查看web容器的环境变量：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -rm --name web --link db:db training/webapp env</span><br><span class="line">...</span><br><span class="line">DB_NAME=/web2/db</span><br><span class="line">DB_PORT=tcp://172.17.0.5:5432</span><br><span class="line">DB_PORT_5000_TCP=tcp://172.17.0.5:5432</span><br><span class="line">DB_PORT_5000_TCP_PROTO=tcp</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中DB_开头的环境变量是供web容器连接db容器使用的，前缀采用大写的连接别名。</p><p>除了环境变量之外，Docker还添加host信息到父容器的<code>/etc/hosts</code>文件。</p><p>下面是父容器web的hosts文件：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -rm --name web --link db:db training/webapp /bin/bash</span><br><span class="line">$ cat /etc/hosts</span><br><span class="line">172.17.0.7 aed84ee21bde</span><br><span class="line">...</span><br><span class="line">172.17.0.5 db</span><br></pre></td></tr></table></figure><p>这里有两个hosts信息，第一个是web容器，web容器用自己的id作为默认主机名，第二个是db容器的IP和主机名。</p><p>用户可以连接多个子容器到父容器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了通过网络访问外，Docker还提供了两个很方便的功能来满足服务访问的基本需求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个是允许映射容器内应用的服务端口到本地宿主主机；&lt;/li&gt;&lt;li&gt;另一个是互联机制实现多个容器间通过容器名来快速访问。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;端口映射实现访问容器&quot;&gt;&lt;a href=&quot;#端口映射实现访问容器&quot; class=&quot;headerlink&quot; title=&quot;端口映射实现访问容器&quot;&gt;&lt;/a&gt;端口映射实现访问容器&lt;/h2&gt;&lt;h3 id=&quot;从外部访问容器应用&quot;&gt;&lt;a href=&quot;#从外部访问容器应用&quot; class=&quot;headerlink&quot; title=&quot;从外部访问容器应用&quot;&gt;&lt;/a&gt;从外部访问容器应用&lt;/h3&gt;&lt;p&gt;在启动容器时，如果不指定对应的参数，在容器外是无法通过网络访问容器内的网络应用和服务的。&lt;/p&gt;&lt;p&gt;当容器中运行一些网络应用，要让外部访问这些应用时，可以通过&lt;code&gt;-P&lt;/code&gt;或&lt;code&gt;-p&lt;/code&gt;参数来指定端口映射。当使用&lt;code&gt;-P&lt;/code&gt;(大写)标记时，Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口。&lt;/p&gt;&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;(小写)可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有&lt;code&gt;IP:HostPort:ContainerPort&lt;/code&gt; | &lt;code&gt;IP::ContainerPort&lt;/code&gt; | &lt;code&gt;HostPort:ContainerPort&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.lovexue.xyz/categories/docker/"/>
    
    
      <category term="Docker" scheme="http://www.lovexue.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>查找给定值的k个最接近的元素</title>
    <link href="http://www.lovexue.xyz/algorithms/bf55dfa7/"/>
    <id>http://www.lovexue.xyz/algorithms/bf55dfa7/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-20T03:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找给定值的k个最接近的元素"><a href="#查找给定值的k个最接近的元素" class="headerlink" title="查找给定值的k个最接近的元素"></a>查找给定值的k个最接近的元素</h2><p>给定一个有序数组arr[]和一个值X，在arr[]中找到与X最接近的k个元素。请注意，如果元素存在于数组中，则不应该输出，只需要其他最接近的元素。</p><p>算法思路：</p><ul><li>首先用二分搜索找到最接近X的交叉点（交叉点之前的元素小于或等于X，之后的元素大于或等于X）。这一步需要$O\left( \log n\right)$次。</li><li>一旦我们找到交叉点，我们可以比较交叉点两侧的元素来打印k个最接近的元素。这一步需要$O\left( k\right)$次。<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Java program to find k closest elements to a given value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KClosest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Function to find the cross over point (the point before</span></span><br><span class="line"><span class="comment">       which elements are smaller than or equal to x and after</span></span><br><span class="line"><span class="comment">       which greater than x)*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCrossOver</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Base cases</span></span><br><span class="line">        <span class="keyword">if</span> (arr[high] &lt;= x) <span class="comment">// x is greater than all</span></span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] &gt; x)  <span class="comment">// x is smaller than all</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the middle point</span></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;  <span class="comment">/* low + (high - low)/2 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If x is same as middle element, then return mid */</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= x &amp;&amp; arr[mid + <span class="number">1</span>] &gt;= x)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If x is greater than arr[mid], then either arr[mid + 1]</span></span><br><span class="line"><span class="comment">          is ceiling of x or ceiling lies in arr[mid+1...high] */</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; x)</span><br><span class="line">            <span class="keyword">return</span> findCrossOver(arr, mid + <span class="number">1</span>, high, x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findCrossOver(arr, low, mid - <span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function prints k closest elements to x in arr[].</span></span><br><span class="line">    <span class="comment">// n is the number of elements in arr[]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printKclosest</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Find the crossover point</span></span><br><span class="line">        <span class="keyword">int</span> l = findCrossOver(arr, <span class="number">0</span>, n - <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">int</span> r = l + <span class="number">1</span>;   <span class="comment">// Right index to search</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// To keep track of count of elements</span></span><br><span class="line">        <span class="comment">// already printed</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If x equals to arr[l], then reduce left index</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; arr[l] == x) l--;</span><br><span class="line">        <span class="comment">// If x equals to arr[r], then increase right index</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; arr[r] == x) r++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compare elements on left and right of crossover</span></span><br><span class="line">        <span class="comment">// point to find the k closest elements</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; count &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - arr[l] &lt; arr[r] - x)</span><br><span class="line">                System.out.print(arr[l--] + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(arr[r++] + <span class="string">" "</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are no more elements on right side, then</span></span><br><span class="line">        <span class="comment">// print left elements</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; k &amp;&amp; l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(arr[l--] + <span class="string">" "</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are no more elements on left side, then</span></span><br><span class="line">        <span class="comment">// print right elements</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; k &amp;&amp; r &lt; n) &#123;</span><br><span class="line">            System.out.print(arr[r++] + <span class="string">" "</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Driver program to check above functions */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        KClosest ob = <span class="keyword">new</span> KClosest();</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>, k = <span class="number">2</span>;</span><br><span class="line">        ob.printKclosest(arr, x, k, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>时间复杂度：$O\left( \log n+k\right)$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查找给定值的k个最接近的元素&quot;&gt;&lt;a href=&quot;#查找给定值的k个最接近的元素&quot; class=&quot;headerlink&quot; title=&quot;查找给定值的k个最接近的元素&quot;&gt;&lt;/a&gt;查找给定值的k个最接近的元素&lt;/h2&gt;&lt;p&gt;给定一个有序数组arr[]和一个值X，在arr[]中找到与X最接近的k个元素。请注意，如果元素存在于数组中，则不应该输出，只需要其他最接近的元素。&lt;/p&gt;&lt;p&gt;算法思路：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先用二分搜索找到最接近X的交叉点（交叉点之前的元素小于或等于X，之后的元素大于或等于X）。这一步需要$O\left( \log n\right)$次。&lt;/li&gt;&lt;li&gt;一旦我们找到交叉点，我们可以比较交叉点两侧的元素来打印k个最接近的元素。这一步需要$O\left( k\right)$次。
    
    </summary>
    
      <category term="Algorithms" scheme="http://www.lovexue.xyz/categories/algorithms/"/>
    
    
      <category term="算法" scheme="http://www.lovexue.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://www.lovexue.xyz/algorithms/735e5788/"/>
    <id>http://www.lovexue.xyz/algorithms/735e5788/</id>
    <published>2018-03-18T16:00:00.000Z</published>
    <updated>2018-03-20T04:52:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法通过重复查找未排序部分的最小元素（考虑升序）并将其放在开头来排序数组。算法在给定数组中维护两个子数组。</p><ul><li>已经排序好的子数组</li><li>剩下未排序的子数组</li></ul><p>在选择排序的每一次迭代中，挑选未排序子数组中的最小元素（考虑升序），并将其移至排序后的子数组中。<br><a id="more"></a><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program for implementation of Selection Sort</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// One by one move boundary of unsorted subarray</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Find the minimum element in unsorted array</span></span><br><span class="line">            <span class="keyword">int</span> min_idx = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min_idx])</span><br><span class="line">                    min_idx = j;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Swap the found minimum element with the first element</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[min_idx];</span><br><span class="line">            arr[min_idx] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Prints the array</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Driver code to test above</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SelectionSort ob = <span class="keyword">new</span> SelectionSort();</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">64</span>,<span class="number">25</span>,<span class="number">12</span>,<span class="number">22</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        ob.sort(arr);</span><br><span class="line">        System.out.println(<span class="string">"Sorted array"</span>);</span><br><span class="line">        ob.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>时间复杂度：$O\left( n^{2}\right)$</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序通过反复交换相邻元素（如果顺序错误）来工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program for implementation of Bubble Sort</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// swap temp and arr[i]</span></span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Prints the array */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Driver method to test above</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BubbleSort ob = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">        ob.bubbleSort(arr);</span><br><span class="line">        System.out.println(<span class="string">"Sorted array"</span>);</span><br><span class="line">        ob.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化实现：</strong> 即使数组已经有序，上述函数也会运行$O\left( n^{2}\right)$时间。如果内部循环没有引起任何交换，可以通过停止算法来优化它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optimized java implementation of Bubble sort </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// An optimized version of Bubble Sort</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">boolean</span> swapped;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            swapped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// swap arr[j] and arr[j+1]</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// IF no two elements were </span></span><br><span class="line">            <span class="comment">// swapped by inner loop, then break</span></span><br><span class="line">            <span class="keyword">if</span> (swapped == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Function to print an array </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Driver program</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        bubbleSort(arr, n);</span><br><span class="line">        System.out.println(<span class="string">"Sorted array: "</span>);</span><br><span class="line">        printArray(arr, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( n^{2}\right)$</p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort an arr[] of size n</span></span><br><span class="line">insertionSort(arr, n)</span><br><span class="line">Loop from i = <span class="number">1</span> to n-<span class="number">1</span>.</span><br><span class="line">……a) Pick element arr[i] and insert it into sorted sequence arr[<span class="number">0</span>…i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program for implementation of Insertion Sort</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/*Function to sort array using insertion sort*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* Move elements of arr[0..i-1], that are</span></span><br><span class="line"><span class="comment">               greater than key, to one position ahead</span></span><br><span class="line"><span class="comment">               of their current position */</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j = j-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* A utility function to print array of size n*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        InsertionSort ob = <span class="keyword">new</span> InsertionSort();        </span><br><span class="line">        ob.sort(arr);</span><br><span class="line">         </span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( n^{2}\right)$</p><h3 id="链表的插入排序"><a href="#链表的插入排序" class="headerlink" title="链表的插入排序"></a>链表的插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="function">Create an empty <span class="title">sorted</span> <span class="params">(or result)</span> list</span></span><br><span class="line"><span class="function">2) Traverse the given list, <span class="keyword">do</span> following <span class="keyword">for</span> every node.</span></span><br><span class="line"><span class="function">......a) Insert current node in sorted way in sorted or result list.</span></span><br><span class="line"><span class="function">3) Change head of given linked list to head of <span class="title">sorted</span> <span class="params">(or result)</span> list.</span></span><br></pre></td></tr></table></figure><h2 id="归并排序（Merge-Sort）——分治思想"><a href="#归并排序（Merge-Sort）——分治思想" class="headerlink" title="归并排序（Merge Sort）——分治思想"></a>归并排序（Merge Sort）——分治思想</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(arr[], l,  r)</span><br><span class="line">If r &gt; l</span><br><span class="line">     <span class="number">1</span>. Find the middle point to divide the array into two halves:  </span><br><span class="line">             middle m = (l+r)/<span class="number">2</span></span><br><span class="line">     <span class="number">2</span>. Call mergeSort <span class="keyword">for</span> first half:   </span><br><span class="line">             <span class="function">Call <span class="title">mergeSort</span><span class="params">(arr, l, m)</span></span></span><br><span class="line"><span class="function">     3. Call mergeSort <span class="keyword">for</span> second half:</span></span><br><span class="line"><span class="function">             Call <span class="title">mergeSort</span><span class="params">(arr, m+<span class="number">1</span>, r)</span></span></span><br><span class="line"><span class="function">     4. Merge the two halves sorted in step 2 and 3:</span></span><br><span class="line"><span class="function">             Call <span class="title">merge</span><span class="params">(arr, l, m, r)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java program for Merge Sort */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Merges two subarrays of arr[].</span></span><br><span class="line">    <span class="comment">// First subarray is arr[l..m]</span></span><br><span class="line">    <span class="comment">// Second subarray is arr[m+1..r]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = l, j = m, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                tmp[k] = arr[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k] = arr[j];</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">            tmp[k] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[k] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Main function that sorts arr[l..r] using</span></span><br><span class="line">    <span class="comment">// merge()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Find the middle point</span></span><br><span class="line">            <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Sort first and second halves</span></span><br><span class="line">            sort(arr, l, m);</span><br><span class="line">            sort(arr , m+<span class="number">1</span>, r);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Merge the sorted halves</span></span><br><span class="line">            merge(arr, l, m, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* A utility function to print array of size n */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"Given Array"</span>);</span><br><span class="line">        printArray(arr);</span><br><span class="line"> </span><br><span class="line">        MergeSort ob = <span class="keyword">new</span> MergeSort();</span><br><span class="line">        ob.sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"\nSorted array"</span>);</span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( n\log n\right)$</p><h3 id="链表的归并排序"><a href="#链表的归并排序" class="headerlink" title="链表的归并排序"></a>链表的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(headRef)</span><br><span class="line"><span class="number">1</span>) If head is NULL or there is only one element in the Linked List </span><br><span class="line">    then <span class="keyword">return</span>.</span><br><span class="line"><span class="number">2</span>) Else divide the linked list into two halves.  </span><br><span class="line">      FrontBackSplit(head, &amp;a, &amp;b); <span class="comment">/* a and b are two halves */</span></span><br><span class="line"><span class="number">3</span>) Sort the two halves a and b.</span><br><span class="line">      MergeSort(a);</span><br><span class="line">      MergeSort(b);</span><br><span class="line"><span class="number">4</span>) Merge the sorted a and b and update the head pointer using headRef.</span><br><span class="line">     *headRef = SortedMerge(a, b);</span><br></pre></td></tr></table></figure><p>一下代码巧妙的使用两个指针移动来寻找中间节点，第一个指针每次移动一格，第二个指针每次移动两格，当第二个指针到达末尾时，第一个指针恰好到达中点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to illustrate merge sorted</span></span><br><span class="line"><span class="comment">// of linkedList</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// node a,b;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        node next;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function">node <span class="title">sortedMerge</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/* Base cases */</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Pick either a or b, and recur */</span></span><br><span class="line">        <span class="keyword">if</span> (a.val &lt;= b.val) </span><br><span class="line">        &#123;</span><br><span class="line">            result = a;</span><br><span class="line">            result.next = sortedMerge(a.next, b);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = b;</span><br><span class="line">            result.next = sortedMerge(a, b.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">mergeSort</span><span class="params">(node h)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Base case : if head is null</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.next == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// get the middle of the list</span></span><br><span class="line">        node middle = getMiddle(h);</span><br><span class="line">        node nextofmiddle = middle.next;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// set the next of middle node to null</span></span><br><span class="line">        middle.next = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Apply mergeSort on left list</span></span><br><span class="line">        node left = mergeSort(h);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Apply mergeSort on right list</span></span><br><span class="line">        node right = mergeSort(nextofmiddle);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Merge the left and right lists</span></span><br><span class="line">        node sortedlist = sortedMerge(left, right);</span><br><span class="line">        <span class="keyword">return</span> sortedlist;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Utility function to get the middle of the linked list</span></span><br><span class="line">    <span class="function">node <span class="title">getMiddle</span><span class="params">(node h)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Base case</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        node fastptr = h.next;</span><br><span class="line">        node slowptr = h;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// Move fastptr by two and slow ptr by one</span></span><br><span class="line">        <span class="comment">// Finally slowptr will point to middle node</span></span><br><span class="line">        <span class="keyword">while</span> (fastptr != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fastptr = fastptr.next;</span><br><span class="line">            <span class="keyword">if</span>(fastptr!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slowptr = slowptr.next;</span><br><span class="line">                fastptr=fastptr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowptr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> new_data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* allocate node */</span></span><br><span class="line">        node new_node = <span class="keyword">new</span> node(new_data);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* link the old list off the new node */</span></span><br><span class="line">        new_node.next = head;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* move the head to point to the new node */</span></span><br><span class="line">        head = new_node;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Utility function to print the linked list</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(node headref)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (headref != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(headref.val + <span class="string">" "</span>);</span><br><span class="line">            headref = headref.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> </span><br><span class="line">        linkedList li = <span class="keyword">new</span> linkedList();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Let us create a unsorted linked lists to test the functions Created</span></span><br><span class="line"><span class="comment">         * lists shall be a: 2-&gt;3-&gt;20-&gt;5-&gt;10-&gt;15</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        li.push(<span class="number">15</span>);</span><br><span class="line">        li.push(<span class="number">10</span>);</span><br><span class="line">        li.push(<span class="number">5</span>);</span><br><span class="line">        li.push(<span class="number">20</span>);</span><br><span class="line">        li.push(<span class="number">3</span>);</span><br><span class="line">        li.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"Linked List without sorting is :"</span>);</span><br><span class="line">        li.printList(li.head);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Apply merge Sort</span></span><br><span class="line">        li.head = li.mergeSort(li.head);</span><br><span class="line">        System.out.print(<span class="string">"\n Sorted Linked List is: \n"</span>);</span><br><span class="line">        li.printList(li.head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>堆排序是基于Binary Heap数据结构的基于比较的排序算法。它类似于我们首先找到最大元素然后和最后位置交换的选择排序。我们对剩下的元素重复相同的过程。</p><h3 id="什么是Binary-Heap"><a href="#什么是Binary-Heap" class="headerlink" title="什么是Binary Heap"></a>什么是Binary Heap</h3><p>Binary Heap是一个完整二叉树，其中项以特殊顺序存储，使得父节点中的值比其两个子节点中的值更大（或更小）。前者称为最大堆，后者称为最小堆。堆可以用二叉树或数组表示。</p><p><strong>用数组表示Binary Heap，如果父节点存储在索引<code>i</code>处，则左边的孩子索引为<code>2 * i + 1</code>，右边的孩子索引为<code>2 * i + 2</code>（假设索引从0开始）。</strong></p><p>按升序排序的堆排序算法：</p><ul><li>根据输入数据构建一个最大堆。</li><li>此时，最大的元素存储在堆的根。将它和堆的最后一项交换，然后将堆的大小减1。最后，heapify树的根。</li><li>在堆大小大于1的情况下重复上述步骤。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program for implementation of Heap Sort</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Build heap (rearrange array)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// One by one extract an element from heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Move current root to end</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// call max heapify on the reduced heap</span></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// To heapify a subtree rooted with node i which is</span></span><br><span class="line">    <span class="comment">// an index in arr[]. n is size of heap</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = i;  <span class="comment">// Initialize largest as root</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span>*i + <span class="number">1</span>;  <span class="comment">// left = 2*i + 1</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">2</span>*i + <span class="number">2</span>;  <span class="comment">// right = 2*i + 2</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If left child is larger than root</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])</span><br><span class="line">            largest = l;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If right child is larger than largest so far</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])</span><br><span class="line">            largest = r;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If largest is not root</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> swap = arr[i];</span><br><span class="line">            arr[i] = arr[largest];</span><br><span class="line">            arr[largest] = swap;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Recursively heapify the affected sub-tree</span></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* A utility function to print array of size n */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Driver program</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"> </span><br><span class="line">        HeapSort ob = <span class="keyword">new</span> HeapSort();</span><br><span class="line">        ob.sort(arr);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"Sorted array is"</span>);</span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( n\log n\right)$</p><h3 id="堆排序的应用"><a href="#堆排序的应用" class="headerlink" title="堆排序的应用"></a>堆排序的应用</h3><ul><li>对几乎排好序的（或K个排好序的）数组进行排序。</li><li>求数组中的k个最大（或最小）元素。</li></ul><h2 id="快速排序（QuickSort）——分治思想"><a href="#快速排序（QuickSort）——分治思想" class="headerlink" title="快速排序（QuickSort）——分治思想"></a>快速排序（QuickSort）——分治思想</h2><p>快排选择一个元素作为枢轴（pivot），并将给定的数组根据选取的枢轴分区。有许多选择枢轴不同的方式。</p><ul><li>始终选择第一个元素作为枢轴。</li><li>总是选择最后一个元素作为枢轴。</li><li>选择一个随机元素作为枢轴。</li><li>选择中位数为枢轴。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/01/QuickSort2.png" alt=""></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=partition(arr, low, high);        <span class="comment">//将数组分为两部分</span></span><br><span class="line">        qsort(arr, low, pivot-<span class="number">1</span>);                   <span class="comment">//递归排序左子数组</span></span><br><span class="line">        qsort(arr, pivot+<span class="number">1</span>, high);                  <span class="comment">//递归排序右子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];     <span class="comment">//枢轴记录</span></span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low&lt;high &amp;&amp; arr[high]&gt;=pivot) --high;</span><br><span class="line">        arr[low]=arr[high];             <span class="comment">//交换比枢轴小的记录到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low&lt;high &amp;&amp; arr[low]&lt;=pivot) ++low;</span><br><span class="line">        arr[high] = arr[low];           <span class="comment">//交换比枢轴小的记录到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描完成，枢轴到位</span></span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="comment">//返回的是枢轴的位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( n\log n\right)$</p><p>当最左元素或者最右元素被选为枢轴时，最坏情况发生在以下情形：</p><ul><li>数组已经是相同的顺序。</li><li>数组已经是相反的顺序。</li><li>所有元素都相等。</li></ul><p>所以尽量选择随机元素或者中间的元素或者中位数作为枢轴来避免最坏情况。</p><h2 id="Shell-Sort（希尔排序）"><a href="#Shell-Sort（希尔排序）" class="headerlink" title="Shell Sort（希尔排序）"></a>Shell Sort（希尔排序）</h2><p>希尔排序基本思想为在直接插入排序的思想下设置一个最小增量dk,刚开始dk设置为n/2。进行插入排序，随后再让dk=dk/2,再进行插入排序，直到dk为1时完成最后一次插入排序，此时数组完成排序。<br><img src="https://github.com/maoyunfei/static-sources/blob/master/shellsort.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> lenth)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> incre = lenth;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       incre = incre/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;incre;k++)&#123;    <span class="comment">//根据增量分为若干子序列</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=k+incre;i&lt;lenth;i+=incre)&#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;k;j-=incre)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(array[j]&lt;array[j-incre])&#123;</span><br><span class="line">                       temp = array[j-incre];</span><br><span class="line">                       array[j-incre] = array[j];</span><br><span class="line">                       array[j] = temp;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(incre == <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏时间复杂度为$O\left( n^{2}\right)$；最优时间复杂度为$O\left( n\right)$；平均时间复杂度为$O\left( n^{1.3}\right)$。辅助空间$O\left(1\right)$。稳定性：不稳定。希尔排序的时间复杂度与选取的增量有关，选取合适的增量可减少时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;选择排序（Selection-Sort）&quot;&gt;&lt;a href=&quot;#选择排序（Selection-Sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序（Selection Sort）&quot;&gt;&lt;/a&gt;选择排序（Selection Sort）&lt;/h2&gt;&lt;p&gt;选择排序算法通过重复查找未排序部分的最小元素（考虑升序）并将其放在开头来排序数组。算法在给定数组中维护两个子数组。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;已经排序好的子数组&lt;/li&gt;&lt;li&gt;剩下未排序的子数组&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在选择排序的每一次迭代中，挑选未排序子数组中的最小元素（考虑升序），并将其移至排序后的子数组中。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://www.lovexue.xyz/categories/algorithms/"/>
    
    
      <category term="算法" scheme="http://www.lovexue.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符、字节与编码</title>
    <link href="http://www.lovexue.xyz/other/6d07e1bc/"/>
    <id>http://www.lovexue.xyz/other/6d07e1bc/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-03-15T08:00:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符与编码的发展"><a href="#字符与编码的发展" class="headerlink" title="字符与编码的发展"></a>字符与编码的发展</h2><h3 id="从计算机对多国语言的支持角度看，大致可以分为三个阶段："><a href="#从计算机对多国语言的支持角度看，大致可以分为三个阶段：" class="headerlink" title="从计算机对多国语言的支持角度看，大致可以分为三个阶段："></a>从计算机对多国语言的支持角度看，大致可以分为三个阶段：</h3><table><thead><tr><th></th><th>系统内码</th><th>说明</th><th>系统</th></tr></thead><tbody><tr><td>阶段一</td><td>ASCII</td><td>计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。</td><td>英文 DOS</td></tr><tr><td>阶段二</td><td>ANSI编码<br>(本地化)</td><td>为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 ‘中’ 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。<br><br>不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 <strong>ANSI 编码</strong>。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。<br><br>不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 <strong>ANSI 编码</strong>的文本中。</td><td>中文 DOS，中文 Windows 95/98，日文 Windows 95/98</td></tr><tr><td>阶段三</td><td>UNICODE<br>(国际化)</td><td>为了使国际间信息交流更加方便，国际组织制定了 <strong>UNICODE 字符集</strong>，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。</td><td>Windows NT/2000/XP，Linux，Java</td></tr></tbody></table><a id="more"></a><h3 id="字符串在内存中的存放方法："><a href="#字符串在内存中的存放方法：" class="headerlink" title="字符串在内存中的存放方法："></a>字符串在内存中的存放方法：</h3><ul><li><p>在 ASCII 阶段，<strong>单字节字符串</strong>使用一个字节存放一个字符（SBCS）。比如，”Bob123” 在内存中为：<br><img src="https://github.com/maoyunfei/Other-Notebook/blob/master/images/img1.jpg?raw=true" alt=""></p></li><li><p>在使用 ANSI 编码支持多种语言阶段，每个字符使用一个字节或多个字节来表示（MBCS），因此，这种方式存放的字符也被称作<strong>多字节字符</strong>。比如，”中文123” 在中文 Windows 95 内存中为7个字节，每个汉字占2个字节，每个英文和数字字符占1个字节：<br><br><img src="https://github.com/maoyunfei/Other-Notebook/blob/master/images/img2.jpg?raw=true" alt=""></p></li><li><p>在 UNICODE 被采用之后，计算机存放字符串时，改为存放每个字符在 UNICODE 字符集中的序号。目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS），因此，这种方式存放的字符也被称作<strong>宽字节字符</strong>。比如，字符串 “中文123” 在 Windows 2000 下，内存中实际存放的是 5 个序号：<br><img src="https://github.com/maoyunfei/Other-Notebook/blob/master/images/img3.jpg?raw=true" alt=""><br>一共占 10 个字节。</p></li></ul><h2 id="字符，字节，字符串"><a href="#字符，字节，字符串" class="headerlink" title="字符，字节，字符串"></a>字符，字节，字符串</h2><p>理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分：</p><table><thead><tr><th></th><th>概念描述</th><th>举例</th></tr></thead><tbody><tr><td>字符</td><td>人们使用的记号，抽象意义上的一个符号。</td><td>‘1’, ‘中’, ‘a’, ‘$’, ‘￥’, ……</td></tr><tr><td>字节</td><td>计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。</td><td>0x01, 0x45, 0xFA, ……</td></tr><tr><td>ANSI<br>字符串</td><td>在内存中，如果“字符”是以 <strong>ANSI 编码</strong>形式存在的，一个字符可能使用一个字节或多个字节来表示，那么我们称这种字符串为 ANSI 字符串或者多字节字符串。</td><td>“中文123”（占7字节）</td></tr><tr><td>UNICODE<br>字符串</td><td>在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 <strong>UNICODE 字符串</strong>或者<strong>宽字节字符串</strong>。</td><td>L”中文123”（占10字节）</td></tr></tbody></table><p>由于不同 ANSI 编码所规定的标准是不相同的，因此，对于一个给定的<strong>多字节字符串</strong>，我们必须知道它采用的是哪一种编码规则，才能够知道它包含了哪些“字符”。而对于 <strong>UNICODE 字符串</strong>来说，不管在什么环境下，它所代表的“字符”内容总是不变的。</p><h2 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h2><p>各个国家和地区所制定的不同 ANSI 编码标准中，都只规定了各自语言所需的“字符”。比如：汉字标准（GB2312）中没有规定韩国语字符怎样存储。这些 ANSI 编码标准所规定的内容包含两层含义：</p><ul><li>使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。</li><li>规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。</li></ul><p>各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p><p><strong>“UNICODE 字符集”</strong> 包含了各种语言中使用到的所有“字符”。用来给 UNICODE 字符集编码的标准有很多种，比如：UTF-8, UTF-7, UTF-16, UnicodeLittle, UnicodeBig 等。</p><h2 id="常用的编码简介"><a href="#常用的编码简介" class="headerlink" title="常用的编码简介"></a>常用的编码简介</h2><p>在这里，我们根据编码规则的特点，把所有的编码分成三类：</p><table><thead><tr><th>分类</th><th>编码标准</th><th>说明</th></tr></thead><tbody><tr><td>单字节字符编码</td><td>ISO-8859-1</td><td>最简单的编码规则，每一个字节直接作为一个 UNICODE 字符。比如，[0xD6, 0xD0] 这两个字节，通过 iso-8859-1 转化为字符串时，将直接得到 [0x00D6, 0x00D0] 两个 UNICODE 字符，即 “ÖÐ”。<br>反之，将 UNICODE 字符串通过 iso-8859-1 转化为字节串时，只能正常转化 0~255 范围的字符。</td></tr><tr><td>ANSI编码</td><td>GB2312,<br>BIG5,<br>Shift_JIS,<br>ISO-8859-2<br>……</td><td>把 UNICODE 字符串通过 ANSI 编码转化为“字节串”时，根据各自编码的规定，一个 UNICODE 字符可能转化成一个字节或多个字节。<br>反之，将字节串转化成字符串时，也可能多个字节转化成一个字符。比如，[0xD6, 0xD0] 这两个字节，通过 GB2312 转化为字符串时，将得到 [0x4E2D] 一个字符，即 ‘中’ 字。<br>“ANSI 编码”的特点：<br>1. 这些“ANSI 编码标准”都只能处理各自语言范围之内的 UNICODE 字符。<br>2. “UNICODE 字符”与“转换出来的字节”之间的关系是人为规定的。</td></tr><tr><td>UNICODE 编码</td><td>UTF-8,<br>UTF-16,<br>UnicodeBig<br>……</td><td>与“ANSI 编码”类似的，把字符串通过 UNICODE 编码转化成“字节串”时，一个 UNICODE 字符可能转化成一个字节或多个字节。<br>与“ANSI 编码”不同的是：<br>1. 这些“UNICODE 编码”能够处理所有的 UNICODE 字符。<br>2. “UNICODE 字符”与“转换出来的字节”之间是可以通过计算得到的。</td></tr></tbody></table><p>我们实际上没有必要去深究每一种编码具体把某一个字符编码成了哪几个字节，我们只需要知道<strong>“编码”的概念就是把“字符”转化成“字节”</strong> 就可以了。对于“UNICODE 编码”，由于它们是可以通过计算得到的，因此，在特殊的场合，我们可以去了解某一种“UNICODE 编码”是怎样的规则。</p><h2 id="Java中的字符与字节"><a href="#Java中的字符与字节" class="headerlink" title="Java中的字符与字节"></a>Java中的字符与字节</h2><table><thead><tr><th>类型或操作</th><th>Java</th></tr></thead><tbody><tr><td>字符</td><td><code>char</code></td></tr><tr><td>字节</td><td><code>byte</code></td></tr><tr><td>ANSI字符串</td><td><code>byte[]</code></td></tr><tr><td>UNICODE字符串</td><td><code>String</code></td></tr><tr><td>字节串→字符串</td><td><code>string = new String(bytes,&quot;encoding&quot;)</code></td></tr><tr><td>字节串→字节串</td><td><code>bytes = string.getBytes(&quot;encoding&quot;)</code></td></tr></tbody></table><p>以上需要注意: Java 中的 char 代表一个 “UNICODE 字符（宽字节字符）”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符与编码的发展&quot;&gt;&lt;a href=&quot;#字符与编码的发展&quot; class=&quot;headerlink&quot; title=&quot;字符与编码的发展&quot;&gt;&lt;/a&gt;字符与编码的发展&lt;/h2&gt;&lt;h3 id=&quot;从计算机对多国语言的支持角度看，大致可以分为三个阶段：&quot;&gt;&lt;a href=&quot;#从计算机对多国语言的支持角度看，大致可以分为三个阶段：&quot; class=&quot;headerlink&quot; title=&quot;从计算机对多国语言的支持角度看，大致可以分为三个阶段：&quot;&gt;&lt;/a&gt;从计算机对多国语言的支持角度看，大致可以分为三个阶段：&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;系统内码&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;th&gt;系统&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;阶段一&lt;/td&gt;&lt;td&gt;ASCII&lt;/td&gt;&lt;td&gt;计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。&lt;/td&gt;&lt;td&gt;英文 DOS&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;阶段二&lt;/td&gt;&lt;td&gt;ANSI编码&lt;br&gt;(本地化)&lt;/td&gt;&lt;td&gt;为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 ‘中’ 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。&lt;br&gt;&lt;br&gt;不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 &lt;strong&gt;ANSI 编码&lt;/strong&gt;。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。&lt;br&gt;&lt;br&gt;不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 &lt;strong&gt;ANSI 编码&lt;/strong&gt;的文本中。&lt;/td&gt;&lt;td&gt;中文 DOS，中文 Windows 95/98，日文 Windows 95/98&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;阶段三&lt;/td&gt;&lt;td&gt;UNICODE&lt;br&gt;(国际化)&lt;/td&gt;&lt;td&gt;为了使国际间信息交流更加方便，国际组织制定了 &lt;strong&gt;UNICODE 字符集&lt;/strong&gt;，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。&lt;/td&gt;&lt;td&gt;Windows NT/2000/XP，Linux，Java&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.lovexue.xyz/categories/other/"/>
    
    
      <category term="编码" scheme="http://www.lovexue.xyz/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Docker数据管理</title>
    <link href="http://www.lovexue.xyz/docker/c2e250ea/"/>
    <id>http://www.lovexue.xyz/docker/c2e250ea/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-03-26T11:57:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器中管理数据主要有两种：</p><ul><li>数据卷：容器内数据直接映射到本地主机环境；</li><li>数据卷容器：使用特定容器维护数据卷。</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount操作。</p><p>数据卷可以提供很多有用的特性，如下所示：<br><a id="more"></a></p><ul><li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；</li><li>对数据卷内数据的修改会立马生效，无论容器内操作还是本地操作；</li><li>对数据卷的更新不会影响镜像，解耦了应用和数据；</li><li>卷会一直存在，直到没有容器使用，可以安全地卸载它。</li></ul><h3 id="在容器内创建一个数据卷"><a href="#在容器内创建一个数据卷" class="headerlink" title="在容器内创建一个数据卷"></a>在容器内创建一个数据卷</h3><p>在用<code>docker run</code>命令时，可以使用<code>-v</code>来创建一个数据卷。从此重复使用<code>-v</code>可以创建多个数据卷。</p><p>使用training/webapp创建一个web容器，并创建一个数据卷挂载到容器的/webapp目录。<br></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p></p><h3 id="挂载一个主机目录作为数据卷-推荐"><a href="#挂载一个主机目录作为数据卷-推荐" class="headerlink" title="挂载一个主机目录作为数据卷(推荐)"></a>挂载一个主机目录作为数据卷(推荐)</h3><p>使用<code>-v</code>标记也可以指定挂载本地的已有目录到容器中去作为数据卷。<br></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p></p><p><strong>本地目录的路径必须是绝对路径，如果目录不存在，docker会自动创建。</strong></p><p>docker挂载数据卷的默认权限是读写(rw)，用户也可以通过ro指定为只读：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p><ul><li>创建一个数据卷容器，并在其中创建一个数据卷挂载到/dbdata:</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><ul><li>查看/dbdata目录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">bin boot dbdata dev src tec ...</span><br></pre></td></tr></table></figure><ul><li>创建db1和db2两个容器，并从dbdata容器挂载数据卷：</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></pre></td></tr></table></figure><p>此时，容器db1和db2都挂载同一个数据卷到相同的/dbdata目录。三个容器任何一方在该目录下的写入，其他容器都可以看见。</p><p>可以多次使用<code>--volomus-from</code>参数来从多个容器加载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d --name db3 --volumes-from db1 training/postgres</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用<code>--volumes-from</code>参数所挂载的数据卷的容器自身并不需要保持在运行状态。<br>如果删除了挂载的容器，数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用<code>docker rm -v</code>命令来指定同时删除关联的数据卷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器中管理数据主要有两种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据卷：容器内数据直接映射到本地主机环境；&lt;/li&gt;&lt;li&gt;数据卷容器：使用特定容器维护数据卷。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;数据卷&quot;&gt;&lt;a href=&quot;#数据卷&quot; class=&quot;headerlink&quot; title=&quot;数据卷&quot;&gt;&lt;/a&gt;数据卷&lt;/h2&gt;&lt;p&gt;数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount操作。&lt;/p&gt;&lt;p&gt;数据卷可以提供很多有用的特性，如下所示：&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.lovexue.xyz/categories/docker/"/>
    
    
      <category term="Docker" scheme="http://www.lovexue.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>搜索算法</title>
    <link href="http://www.lovexue.xyz/algorithms/401ea1e/"/>
    <id>http://www.lovexue.xyz/algorithms/401ea1e/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-19T14:27:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linear-Search-线性搜索"><a href="#Linear-Search-线性搜索" class="headerlink" title="Linear Search(线性搜索)"></a>Linear Search(线性搜索)</h2><p><strong>问题：</strong> 给定一个有n个元素的数组，写一个函数在数组中搜索给定元素。<br><img src="https://github.com/maoyunfei/static-sources/blob/master/LinearSearch.png?raw=true" alt=""><br><a id="more"></a></p><blockquote><p>Java实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearSearch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This function returns index of element x in arr[]</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Return the index of the element if the element</span></span><br><span class="line">            <span class="comment">// is found</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == x)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return -1 if the element is not found</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( n\right)$</p><h2 id="Binary-Search-二分查找"><a href="#Binary-Search-二分查找" class="headerlink" title="Binary Search(二分查找)"></a>Binary Search(二分查找)</h2><p><strong>问题：</strong> 给定一个有n个元素的<strong>有序</strong>数组，写一个函数在数组中搜索给定元素。<br><img src="https://github.com/maoyunfei/static-sources/blob/master/binary-search.png?raw=true" alt=""></p><blockquote><p>Java实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java implementation of recursive Binary Search</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Returns index of x if it is present in arr[l..</span></span><br><span class="line">    <span class="comment">// r], else return -1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r&gt;=l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the element is present at the</span></span><br><span class="line">            <span class="comment">// middle itself</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == x)</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If element is smaller than mid, then</span></span><br><span class="line">            <span class="comment">// it can only be present in left subarray</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; x)</span><br><span class="line">               <span class="keyword">return</span> binarySearch(arr, l, mid-<span class="number">1</span>, x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Else the element can only be present</span></span><br><span class="line">            <span class="comment">// in right subarray</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, r, x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We reach here when element is not present</span></span><br><span class="line">        <span class="comment">//  in array</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method to test above</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BinarySearch ob = <span class="keyword">new</span> BinarySearch();</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">40</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> result = ob.binarySearch(arr,<span class="number">0</span>,n-<span class="number">1</span>,x);</span><br><span class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">"Element not present"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Element found at index "</span> +</span><br><span class="line">                                                 result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( \log n\right)$</p><p>适用场景：<strong>有序</strong></p><h2 id="Jump-Search-跳跃搜索"><a href="#Jump-Search-跳跃搜索" class="headerlink" title="Jump Search(跳跃搜索)"></a>Jump Search(跳跃搜索)</h2><p>Jump Search是用于<strong>有序</strong>数组的搜索算法。基本思想是通过以固定步长向前跳跃或跳过一些元素来代替搜索所有元素来检查更少的元素(而不是线性搜索)。</p><p>例如，假设我们有一个大小为n的数组arr[]和大小为m的块（将被跳转）。然后我们搜索索引arr [0]，arr[m]，arr[2m] … ..arr[km]等等。一旦我们找到了间隔(arr[km] &lt; x &lt;arr [(k + 1)m])，我们就从索引km开始执行线性搜索操作来查找元素x。</p><p><strong>什么是最佳跳跃步长?</strong></p><p>在最坏的情况下，我们必须进行n/m跳转，并且如果最后一次选中的值大于要搜索的元素，我们将对线性搜索进行m-1比较。因此，最坏情况下的比较总数将是<code>((n/m)+ m-1)</code>。当m =√n时，函数的值<code>((n/m)+m-1)</code>最小。因此，<strong>最好的步长是m=√n</strong>。</p><blockquote><p>Java实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to implement Jump Search.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpSearch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finding block size to be jumped</span></span><br><span class="line">        <span class="keyword">int</span> step = (<span class="keyword">int</span>)Math.floor(Math.sqrt(n));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finding the block where element is</span></span><br><span class="line">        <span class="comment">// present (if it is present)</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[Math.min(step, n)-<span class="number">1</span>] &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = step;</span><br><span class="line">            step += (<span class="keyword">int</span>)Math.floor(Math.sqrt(n));</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= n)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Doing a linear search for x in block</span></span><br><span class="line">        <span class="comment">// beginning with prev.</span></span><br><span class="line">        <span class="keyword">while</span> (arr[prev] &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            prev++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we reached next block or end of</span></span><br><span class="line">            <span class="comment">// array, element is not present.</span></span><br><span class="line">            <span class="keyword">if</span> (prev == Math.min(step, n))</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If element is found</span></span><br><span class="line">        <span class="keyword">if</span> (arr[prev] == x)</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver program to test function</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [ ] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>,</span><br><span class="line">                     <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>, <span class="number">610</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the index of 'x' using Jump Search</span></span><br><span class="line">        <span class="keyword">int</span> index = jumpSearch(arr, x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the index where 'x' is located</span></span><br><span class="line">        System.out.println(<span class="string">"\nNumber "</span> + x +</span><br><span class="line">                            <span class="string">" is at index "</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( \sqrt {n}\right)$</p><p>适用场景：<strong>有序</strong></p><p><strong>Binary Search优于Jump Search，但Jump Search有一个优势，即我们只返回一次(Binary Search可能需要高达O(Log n)个跳转)。因此，在跳回成本高昂的系统中，我们使用Jump Search。</strong></p><h2 id="Interpolation-Search-插值搜索"><a href="#Interpolation-Search-插值搜索" class="headerlink" title="Interpolation Search(插值搜索)"></a>Interpolation Search(插值搜索)</h2><p>给定一个有n个均匀分布值值的<strong>有序</strong>数组，编写一个函数来搜索数组中的特定元素。</p><p>插值搜索是对二分搜索的改进，其中排序数组中的值均匀分布。二分查找总是对中间元素进行检查。插值搜索可能会根据正在搜索的值进入不同的位置。例如，如果搜索的值更接近最后一个元素，则插值搜索可能会从结尾开始搜索。</p><p>要找到要搜索的位置，它使用以下公式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">公式的想法当要搜索的元素更接近arr[hi]，则返回较大的pos值，</span><br><span class="line">如果要搜索的元素更接近[lo]，则返回较小的pos值。</span><br><span class="line">pos = lo + [(x-arr[lo])*(hi-lo)/(arr[hi]-arr[Lo])]</span><br><span class="line"></span><br><span class="line">arr[] ==&gt; Array where elements need to be searched</span><br><span class="line">x     ==&gt; Element to be searched</span><br><span class="line">lo    ==&gt; Starting index in arr[]</span><br><span class="line">hi    ==&gt; Ending index in arr[]</span><br></pre></td></tr></table></figure><blockquote><p>Java实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to implement interpolation search</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterpolationSearch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Array of items on which search will</span></span><br><span class="line">    <span class="comment">// be conducted.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>,</span><br><span class="line">                                         <span class="number">24</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">47</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If x is present in arr[0..n-1], then returns</span></span><br><span class="line">    <span class="comment">// index of it, else returns -1.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Find indexes of two corners</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = (arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Since array is sorted, an element present</span></span><br><span class="line">        <span class="comment">// in array must be in range defined by corner</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; x &gt;= arr[lo] &amp;&amp; x &lt;= arr[hi])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Probing the position with keeping</span></span><br><span class="line">            <span class="comment">// uniform distribution in mind.</span></span><br><span class="line">            <span class="keyword">int</span> pos = lo + (((hi-lo) /</span><br><span class="line">                  (arr[hi]-arr[lo]))*(x - arr[lo]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Condition of target found</span></span><br><span class="line">            <span class="keyword">if</span> (arr[pos] == x)</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If x is larger, x is in upper part</span></span><br><span class="line">            <span class="keyword">if</span> (arr[pos] &lt; x)</span><br><span class="line">                lo = pos + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If x is smaller, x is in lower part</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = pos - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> x = <span class="number">18</span>; <span class="comment">// Element to be searched</span></span><br><span class="line">         <span class="keyword">int</span> index = interpolationSearch(x);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If element was found</span></span><br><span class="line">         <span class="keyword">if</span> (index != -<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">"Element found at index "</span> + index);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Element not found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( \log \log n\right)$</p><p>适用场景：<strong>有序</strong>、<strong>均匀分布</strong></p><h2 id="Exponential-Search-指数搜索"><a href="#Exponential-Search-指数搜索" class="headerlink" title="Exponential Search(指数搜索)"></a>Exponential Search(指数搜索)</h2><p>指数搜索涉及两个步骤：(1)查找元素存在的范围；(2)在上面找到的范围中进行二分查找。</p><p><strong>如何找到元素可能存在的范围？</strong></p><p>这个想法是从子数组大小1开始，比较它的最后一个元素和x，然后尝试大小2，然后是4，直到子数组的最后一个元素不会更大。 一旦我们找到了一个索引i（在重复了i次之后），我们知道该元素必须存在于i / 2和i之间（为什么是i / 2？因为我们在以前的迭代中找不到更大的值）</p><blockquote><p>Java实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java     program to find an element x in a</span></span><br><span class="line"><span class="comment">// sorted array using Exponential search.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExponentialSearch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Returns position of first ocurrence of</span></span><br><span class="line">    <span class="comment">// x in array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exponentialSearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// If x is present at firt location itself</span></span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find range for binary search by</span></span><br><span class="line">        <span class="comment">// repeated doubling</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; arr[i] &lt;= x)</span><br><span class="line">            i = i*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Call binary search for the found range.</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.binarySearch(arr, i/<span class="number">2</span>, Math.min(i, n), x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">40</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> result = exponentialSearch(arr, arr.length, x);</span><br><span class="line"></span><br><span class="line">        System.out.println((result &lt; <span class="number">0</span>) ? <span class="string">"Element is not present in array"</span> :</span><br><span class="line">                                   <span class="string">"Element is present at index "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left( \log n\right)$</p><p>适用场景：<strong>有序</strong></p><p><strong>当目标元素更靠近开始位置时，Exponential Search优于Binary Search。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linear-Search-线性搜索&quot;&gt;&lt;a href=&quot;#Linear-Search-线性搜索&quot; class=&quot;headerlink&quot; title=&quot;Linear Search(线性搜索)&quot;&gt;&lt;/a&gt;Linear Search(线性搜索)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt; 给定一个有n个元素的数组，写一个函数在数组中搜索给定元素。&lt;br&gt;&lt;img src=&quot;https://github.com/maoyunfei/static-sources/blob/master/LinearSearch.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://www.lovexue.xyz/categories/algorithms/"/>
    
    
      <category term="算法" scheme="http://www.lovexue.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器相关命令</title>
    <link href="http://www.lovexue.xyz/docker/fab65d8b/"/>
    <id>http://www.lovexue.xyz/docker/fab65d8b/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-03-12T12:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker容器的常用命令如下，详细信息也可以查看<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h2><p>使用<code>docker run</code>命令可以新建并启动一个容器。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><a id="more"></a><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td></td><td>后台运行</td></tr><tr><td><code>-P</code></td><td></td><td>随机端口映射</td></tr><tr><td><code>-p</code></td><td></td><td>指定端口映射 (格式：-p hostPort:containerPort)</td></tr><tr><td><code>--network</code></td><td></td><td>指定网络模式</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> java /bin/echo 'Hello World'</span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -p 91:80 nginx</span><br></pre></td></tr></table></figure><p><strong>提醒：</strong>使用docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个Docker容器。</p><h2 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h2><p>使用<code>docker ps</code>命令列出运行中的容器。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--all , -a</code></td><td><code>false</code></td><td>列出所有容器(包括未运行的)</td></tr><tr><td><code>--filter , -f</code></td><td></td><td>根据条件过滤</td></tr><tr><td><code>--last , -n</code></td><td><code>-1</code></td><td>显示最近创建的n个容器(无论状态)</td></tr><tr><td><code>--no-trunc</code></td><td><code>false</code></td><td>不截断输出</td></tr><tr><td><code>--quite , -q</code></td><td><code>false</code></td><td>静默模式，只显示容器ID</td></tr><tr><td><code>--size , -s</code></td><td><code>false</code></td><td>显示总文件大小</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -n <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -q</span><br></pre></td></tr></table></figure><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>使用<code>docker stop</code>命令可以停止容器。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [options] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--time , -t</code></td><td><code>10</code></td><td>杀死容器前等待其停止的时间，单位是秒</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop <span class="number">784</span>fd3b294d7</span><br><span class="line">docker stop nginx</span><br></pre></td></tr></table></figure><h2 id="强行停止容器"><a href="#强行停止容器" class="headerlink" title="强行停止容器"></a>强行停止容器</h2><p>使用<code>docker kill</code>命令强行停止容器</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [options] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--siginal , -s</code></td><td><code>KILL</code></td><td>向容器发送信号</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker kill <span class="number">784</span>fd3b294d7</span><br><span class="line">docker kill nginx</span><br></pre></td></tr></table></figure><h2 id="启动已停止容器"><a href="#启动已停止容器" class="headerlink" title="启动已停止容器"></a>启动已停止容器</h2><p>使用<code>docker start</code>命令可以启动已停止的容器。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [options] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start <span class="number">784</span>fd3b294d7</span><br><span class="line">docker start nginx</span><br></pre></td></tr></table></figure><h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><p>使用<code>docker restart</code>命令可以重启容器。实际上是先执行了<code>docker stop</code>命令，然后再执行<code>docker start</code>命令。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [options] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--time , -t</code></td><td><code>10</code></td><td>杀死容器前等待其停止的时间，单位是秒</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker restart <span class="number">784</span>fd3b294d7</span><br><span class="line">docker restart nginx</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>有多种方式进入容器，最简单的方式是使用<code>docker exec</code>命令。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="number">784</span>fd3b294d7 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>使用<code>docker rm</code>命令可以删除容器。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [options] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--force , -f</code></td><td><code>false</code></td><td>通过SIGKILL信号强制删除正在运行中的容器</td></tr><tr><td><code>--link , -l</code></td><td><code>false</code></td><td>删除容器间的网络连接</td></tr><tr><td><code>--volumes , -v</code></td><td><code>false</code></td><td>删除与容器关联的卷</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm <span class="number">784</span>fd3b294d7</span><br><span class="line">docker rm -f nginx</span><br></pre></td></tr></table></figure><p>删除所有的容器:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker容器的常用命令如下，详细信息也可以查看&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/docker/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;h2 id=&quot;新建并启动容器&quot;&gt;&lt;a href=&quot;#新建并启动容器&quot; class=&quot;headerlink&quot; title=&quot;新建并启动容器&quot;&gt;&lt;/a&gt;新建并启动容器&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;docker run&lt;/code&gt;命令可以新建并启动一个容器。&lt;/p&gt;&lt;p&gt;命令格式：&lt;/p&gt;&lt;figure class=&quot;highlight docker&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker &lt;span class=&quot;keyword&quot;&gt;run&lt;/span&gt; [OPTIONS] IMAGE [COMMAND] [ARG...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.lovexue.xyz/categories/docker/"/>
    
    
      <category term="Docker命令" scheme="http://www.lovexue.xyz/tags/Docker%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像相关命令</title>
    <link href="http://www.lovexue.xyz/docker/7dd9962d/"/>
    <id>http://www.lovexue.xyz/docker/7dd9962d/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-03-09T09:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker镜像的常用命令如下，详细信息也可以查看<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>使用<code>docker search</code>命令可以搜索远端仓库共享的镜像，默认是Docker Hub中的镜像。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [options] TERM</span><br></pre></td></tr></table></figure><a id="more"></a><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--automated</code></td><td><code>false</code></td><td>仅显示自动构建的镜像</td></tr><tr><td><code>--filter , -f</code></td><td></td><td>根据指定条件过滤</td></tr><tr><td><code>--limit</code></td><td><code>25</code></td><td>搜索结果的最大条数</td></tr><tr><td><code>--no-trunc</code></td><td><code>false</code></td><td>输出信息不截断显示</td></tr><tr><td><code>--stars , -s</code></td><td><code>0</code></td><td>仅显示star大于指定星级的镜像，0表示输出所有镜像</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search -s <span class="number">10</span> nginx</span><br></pre></td></tr></table></figure><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>使用<code>docker pull</code>命令直接从Docker Hub下载镜像。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [options] NAME[:TAG]</span><br></pre></td></tr></table></figure><p>其中，NAME是镜像仓库的名称，TAG是镜像的标签。通常情况下，描述一个镜像需要包括“名称+标签”信息。</p><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--all-tags , -a</code></td><td><code>false</code></td><td>下载所有标签的镜像</td></tr><tr><td><code>--disable-content-trust</code></td><td><code>false</code></td><td>忽略镜像内容校验</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>如果不指定TAG，默认下载镜像的最新版本。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull myregistry.com/nginx:tag1</span><br></pre></td></tr></table></figure><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>使用<code>docker images</code>命令可以列出本机上已有镜像的基本信息。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [options] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--all , -a</code></td><td><code>false</code></td><td>列出所有镜像(包括隐藏中间层镜像)</td></tr><tr><td><code>--digests</code></td><td><code>false</code></td><td>显示摘要信息</td></tr><tr><td><code>--filter , -f</code></td><td></td><td>显示满足条件的镜像</td></tr><tr><td><code>--format</code></td><td></td><td>使用Go语言模板文件展示镜像</td></tr><tr><td><code>--no-trunc</code></td><td><code>false</code></td><td>输出信息不截断显示</td></tr><tr><td><code>--quite , -q</code></td><td><code>false</code></td><td>只显示镜像ID</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker images nginx</span><br><span class="line">docker images nginx:tag1</span><br><span class="line">docker images --digests</span><br><span class="line">docker images --filter <span class="string">"dangling=true"</span></span><br><span class="line">docker images --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h2><p>使用<code>docker tag</code>命令为本地镜像添加新的标签</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag <span class="number">0</span>e5574283393 fedora/httpd:version1.<span class="number">0</span></span><br><span class="line">docker tag httpd fedora/httpd:version1.<span class="number">0</span></span><br><span class="line">docker tag httpd:test fedora/httpd:version1.<span class="number">0</span>.test</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>使用<code>docker rmi</code>命令可以删除指定镜像。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [options] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--force, -f</code></td><td><code>false</code></td><td>强制删除</td></tr><tr><td><code>--no-prune</code></td><td><code>false</code></td><td>不移除该镜像的过程镜像，默认移除</td></tr></tbody></table><p>示例：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx</span><br><span class="line">docker rmi $&#123;ID&#125;</span><br></pre></td></tr></table></figure><p>删除所有镜像:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images)</span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>通过Dockerfile构建镜像。</p><p>命令格式：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [options] path | url | -</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--file, -f</code></td><td></td><td>指定Dockerfile的名称，默认是‘PATH/Dockerfile’</td></tr><tr><td><code>--no-prune</code></td><td><code>false</code></td><td>不移除该镜像的过程镜像，默认移除</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker镜像的常用命令如下，详细信息也可以查看&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/docker/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;h2 id=&quot;搜索镜像&quot;&gt;&lt;a href=&quot;#搜索镜像&quot; class=&quot;headerlink&quot; title=&quot;搜索镜像&quot;&gt;&lt;/a&gt;搜索镜像&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;docker search&lt;/code&gt;命令可以搜索远端仓库共享的镜像，默认是Docker Hub中的镜像。&lt;/p&gt;&lt;p&gt;命令格式：&lt;/p&gt;&lt;figure class=&quot;highlight docker&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker search [options] TERM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.lovexue.xyz/categories/docker/"/>
    
    
      <category term="Docker命令" scheme="http://www.lovexue.xyz/tags/Docker%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性之Date/Time API</title>
    <link href="http://www.lovexue.xyz/java/7dd3efa4/"/>
    <id>http://www.lovexue.xyz/java/7dd3efa4/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-03-08T03:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是<code>java.util</code>和<code>java.sql</code>中，都包含<code>Date</code>类，如果要处理由<code>java.text.DateFormat</code>类处理。同时<code>java.util.Date</code>中既包含了日期，又包含了时间，所以java 8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方库<code>joda</code>很多的优点。</p><h2 id="对比旧的日期API"><a href="#对比旧的日期API" class="headerlink" title="对比旧的日期API"></a>对比旧的日期API</h2><table><thead><tr><th>Java.time</th><th>java.util.Calendar以及Date</th></tr></thead><tbody><tr><td>流畅的API</td><td>不流畅的API</td></tr><tr><td>实例不可变</td><td>实例可变</td></tr><tr><td>线程安全</td><td>非线程安全</td></tr></tbody></table><a id="more"></a><h2 id="新API介绍"><a href="#新API介绍" class="headerlink" title="新API介绍"></a>新API介绍</h2><h3 id="1、主要的类"><a href="#1、主要的类" class="headerlink" title="1、主要的类:"></a>1、主要的类:</h3><p><strong><code>java.time</code>包下的类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Instant：时间戳  </span><br><span class="line">Duration：持续时间，时间差  </span><br><span class="line">LocalDate：只包含日期，比如：2016-10-20  </span><br><span class="line">LocalTime：只包含时间，比如：23:12:10  </span><br><span class="line">LocalDateTime：包含日期和时间，比如：2016-10-20 23:14:21  </span><br><span class="line">Period：时间段  </span><br><span class="line">ZoneOffset：时区偏移量，比如：+8:00  </span><br><span class="line">ZonedDateTime：带时区的时间  </span><br><span class="line">Clock：时钟，比如获取目前美国纽约的时间</span><br></pre></td></tr></table></figure><p><strong>以及<code>java.time.format</code>包下的类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter：时间格式化</span><br></pre></td></tr></table></figure><h3 id="2、主要的类的值的格式"><a href="#2、主要的类的值的格式" class="headerlink" title="2、主要的类的值的格式:"></a>2、主要的类的值的格式:</h3><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/date_time_api.jpg?raw=true" width="60%" height="60%" align="center"></p><h3 id="3、通过例子来看如何使用java8新的日期时间库"><a href="#3、通过例子来看如何使用java8新的日期时间库" class="headerlink" title="3、通过例子来看如何使用java8新的日期时间库"></a>3、通过例子来看如何使用java8新的日期时间库</h3><h4 id="1-获取今天的日期"><a href="#1-获取今天的日期" class="headerlink" title="(1) 获取今天的日期"></a>(1) 获取今天的日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate todayDate = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"今天的日期："</span>+todayDate);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">今天的日期：<span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="2-指定日期，进行相应操作"><a href="#2-指定日期，进行相应操作" class="headerlink" title="(2) 指定日期，进行相应操作"></a>(2) 指定日期，进行相应操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取2016年10月的第1天</span></span><br><span class="line">LocalDate firstDay = oneday.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">System.out.println(firstDay);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//取2016年10月的第1天，另外一种写法</span></span><br><span class="line">LocalDate firstDay2 = oneday.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">System.out.println(firstDay2);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//取2016年10月的最后1天，不用考虑大月，小月，平年，闰年</span></span><br><span class="line">LocalDate lastDay = oneday.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(lastDay);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//当前日期＋1天</span></span><br><span class="line">LocalDate tomorrow = oneday.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为闰年</span></span><br><span class="line"><span class="keyword">boolean</span> isLeapYear = tomorrow.isLeapYear();</span><br><span class="line">System.out.println(isLeapYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">21</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="3-生日检查或者账单日检查"><a href="#3-生日检查或者账单日检查" class="headerlink" title="(3) 生日检查或者账单日检查"></a>(3) 生日检查或者账单日检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开发过程中，经常需要为过生日的用户送上一些祝福，例如，用户的生日为<span class="number">1990</span>-<span class="number">10</span>-<span class="number">12</span>，如果今天是<span class="number">2016</span>-<span class="number">10</span>-<span class="number">12</span>，那么今天就是用户的</span><br><span class="line"></span><br><span class="line">生日(按公历/身份证日期来算)，那么通过java8新的日期库，我们该如何来进行判断？</span><br><span class="line"></span><br><span class="line">在java <span class="number">8</span>中，可以使用MonthDay，该类不包含年份信息，当然还有一个类是YearMonth</span><br><span class="line"></span><br><span class="line">LocalDate birthday = LocalDate.of(<span class="number">1990</span>, <span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.of(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">12</span>)); </span><br><span class="line">System.out.println(today.equals(birthdayMd));</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="4-获取当前的时间"><a href="#4-获取当前的时间" class="headerlink" title="(4) 获取当前的时间"></a>(4) 获取当前的时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">时间主要是使用LocalTime，该类不包含日期，只有时间信息</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的时间</span></span><br><span class="line">LocalTime nowTime = LocalTime.now(); <span class="comment">//结果14:29:40.558</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//如果不想显示毫秒</span></span><br><span class="line">LocalTime nowTime2 = LocalTime.now().withNano(<span class="number">0</span>); <span class="comment">//14:43:14</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//指定时间</span></span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">14</span>, <span class="number">10</span>, <span class="number">21</span>); <span class="comment">//14:10:21</span></span><br><span class="line">LocalTime time2 = LocalTime.parse(<span class="string">"12:00:01"</span>); <span class="comment">// 12:00:01</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//当前时间增加2小时</span></span><br><span class="line">LocalTime nowTimePlus2Hour = nowTime.plusHours(<span class="number">2</span>); <span class="comment">//16:47:23.144</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LocalTime nowTimePlus2Hour2 = nowTime.plus(<span class="number">2</span>, ChronoUnit.HOURS);</span><br></pre></td></tr></table></figure><h4 id="5-日期前后比较"><a href="#5-日期前后比较" class="headerlink" title="(5) 日期前后比较"></a>(5) 日期前后比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比较<span class="number">2</span>个日期哪个在前，哪个在后，java8 LocalDate提供了<span class="number">2</span>个方法，isAfter(),isBefore</span><br><span class="line"></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate specifyDate = LocalDate.of(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(today.isAfter(specifyDate)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="6-处理不同时区的时间"><a href="#6-处理不同时区的时间" class="headerlink" title="(6) 处理不同时区的时间"></a>(6) 处理不同时区的时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java8中，将日期、时间，时区都很好的进行了分离。</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当前的时区</span></span><br><span class="line">ZoneId defaultZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(defaultZone); <span class="comment">//Asia/Shanghai</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//查看美国纽约当前的时间</span></span><br><span class="line">ZoneId america = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">LocalDateTime shanghaiTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime americaDateTime = LocalDateTime.now(america);</span><br><span class="line">System.out.println(shanghaiTime); <span class="comment">//2016-11-06T15:20:27.996</span></span><br><span class="line">System.out.println(americaDateTime); <span class="comment">//2016-11-06T02:20:27.996 ，可以看到美国与北京时间差了13小时</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//带有时区的时间</span></span><br><span class="line">ZonedDateTime americaZoneDateTime = ZonedDateTime.now(america);</span><br><span class="line">System.out.println(americaZoneDateTime); <span class="comment">//2016-11-06T02:23:44.863-05:00[America/New_York]</span></span><br></pre></td></tr></table></figure><h4 id="7-比较两个日期之前时间差"><a href="#7-比较两个日期之前时间差" class="headerlink" title="(7) 比较两个日期之前时间差"></a>(7) 比较两个日期之前时间差</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在项目中，经常需要比较两个日期之间相差几天，或者相隔几个月，我们可以使用java8的Period来进行处理。</span><br><span class="line"></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate specifyDate = LocalDate.of(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">Period period = Period.between(specifyDate, today);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getDays());  <span class="comment">//4</span></span><br><span class="line">System.out.println(period.getMonths()); <span class="comment">//1</span></span><br><span class="line">System.out.println(specifyDate.until(today, ChronoUnit.DAYS)); <span class="comment">//401</span></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">401</span></span><br><span class="line">我们可以看到，我们使用Period类比较天数，但它返回的值，并不是<span class="number">2</span>个日期之间总共的天数差，而是一个相对天数差，比如<span class="number">5</span>月<span class="number">1</span>日和</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>月<span class="number">2</span>日，他比较的是仅仅<span class="number">2</span>个天之间的差，那<span class="number">1</span>号和<span class="number">2</span>号，相差<span class="number">1</span>天，而实际上，因为中间相差了好几个月，所以真正的天数差肯定不是<span class="number">1</span>天，</span><br><span class="line"></span><br><span class="line">所以我们可以使用until，并指明精度单位是days，就可以计算真正的天数差了。</span><br></pre></td></tr></table></figure><h4 id="8-日期时间格式解析、格式化"><a href="#8-日期时间格式解析、格式化" class="headerlink" title="(8) 日期时间格式解析、格式化"></a>(8) 日期时间格式解析、格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在java8之前，我们进行时间格式化主要是使用SimpleDateFormat，而在java8中，主要是使用DateTimeFormatter，java8中，预定</span><br><span class="line"></span><br><span class="line">义了一些标准的时间格式，我们可以直接将时间转换为标准的时间格式：</span><br><span class="line"></span><br><span class="line">String specifyDate = <span class="string">"20151011"</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;</span><br><span class="line">LocalDate formatted = LocalDate.parse(specifyDate,formatter); </span><br><span class="line">System.out.println(formatted); </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">10</span>-<span class="number">11</span></span><br><span class="line">当然，很多时间标准的时间格式可能也不满足我们的要求，我们需要转为自定义的时间格式</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">"YYYY MM dd"</span>);</span><br><span class="line">System.out.println(formatter2.format(LocalDate.now()));</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">2015</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="9-java8-时间类与Date类的相互转化"><a href="#9-java8-时间类与Date类的相互转化" class="headerlink" title="(9) java8 时间类与Date类的相互转化"></a>(9) java8 时间类与Date类的相互转化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在转换中，我们需要注意，因为java8之前Date是包含日期和时间的，而LocalDate只包含日期，LocalTime只包含时间，所以与Date在</span><br><span class="line"></span><br><span class="line">互转中，势必会丢失日期或者时间，或者会使用起始时间。如果转LocalDateTime，那么就不存在信息误差。</span><br><span class="line"></span><br><span class="line"><span class="comment">//Date与Instant的相互转化</span></span><br><span class="line">Instant instant  = Instant.now();</span><br><span class="line">Date date = Date.from(instant);</span><br><span class="line">Instant instant2 = date.toInstant();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//Date转为LocalDateTime</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.ofInstant(date2.toInstant(), ZoneId.systemDefault());</span><br><span class="line">        </span><br><span class="line"><span class="comment">//LocalDateTime转Date</span></span><br><span class="line">LocalDateTime localDateTime3 = LocalDateTime.now();</span><br><span class="line">Instant instant3 = localDateTime3.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date3 = Date.from(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDate转Date</span></span><br><span class="line"><span class="comment">//因为LocalDate不包含时间，所以转Date时，会默认转为当天的起始时间，00:00:00</span></span><br><span class="line">LocalDate localDate4 = LocalDate.now();</span><br><span class="line">Instant instant4 = localDate4.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date4 = Date.from(instant);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是&lt;code&gt;java.util&lt;/code&gt;和&lt;code&gt;java.sql&lt;/code&gt;中，都包含&lt;code&gt;Date&lt;/code&gt;类，如果要处理由&lt;code&gt;java.text.DateFormat&lt;/code&gt;类处理。同时&lt;code&gt;java.util.Date&lt;/code&gt;中既包含了日期，又包含了时间，所以java 8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方库&lt;code&gt;joda&lt;/code&gt;很多的优点。&lt;/p&gt;&lt;h2 id=&quot;对比旧的日期API&quot;&gt;&lt;a href=&quot;#对比旧的日期API&quot; class=&quot;headerlink&quot; title=&quot;对比旧的日期API&quot;&gt;&lt;/a&gt;对比旧的日期API&lt;/h2&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Java.time&lt;/th&gt;&lt;th&gt;java.util.Calendar以及Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;流畅的API&lt;/td&gt;&lt;td&gt;不流畅的API&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实例不可变&lt;/td&gt;&lt;td&gt;实例可变&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;线程安全&lt;/td&gt;&lt;td&gt;非线程安全&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="Java 8" scheme="http://www.lovexue.xyz/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性之函数式接口和Lambda表达式</title>
    <link href="http://www.lovexue.xyz/java/c8f73c32/"/>
    <id>http://www.lovexue.xyz/java/c8f73c32/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-08T03:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象并不坏，但它给程序带来了很多冗长的内容。例如，假设我们要创建一个Runnable的实例。通常我们使用下面的匿名类来完成它：<br><a id="more"></a><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"My Runnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p></p><p>如果你看看上面的代码，实际使用的部分是 run() 方法中的代码。其余所有的代码是因为Java程序的结构化方式。</p><p>Java 8函数式接口和Lambda表达式通过删除大量的样板代码，帮助我们编写更少、更简洁的代码。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>具有一个抽象方法的接口称为函数式接口。添加了<code>@FunctionalInterface</code>注解，以便我们可以将接口标记为函数式接口。</p><p>使用它不是强制性的，但最好的做法是将它与函数式接口一起使用，以避免意外添加额外的方法。如果接口使用<code>@FunctionalInterface</code>注解进行注释，并且我们尝试使用多个抽象方法，则会引发编译器错误。</p><p><strong>Java 8函数式接口的主要好处是我们可以使用lambda表达式来实例化它们，避免使用笨重的匿名类实现。</strong></p><p>Java 8 Collections API已被重写，并引入了新的Stream API，它使用了许多函数式接口。 Java 8在<code>java.util.function</code>包中定义了很多函数式接口。一些有用的java 8函数式接口如<code>Consumer</code>、<code>Supplier</code>、<code>Function</code>和<code>Predicate</code>。</p><p><code>java.lang.Runnable</code>是使用单一抽象方法 run() 的函数式接口的一个很好的例子。</p><h3 id="下面的代码片段为函数式接口提供了一些指导："><a href="#下面的代码片段为函数式接口提供了一些指导：" class="headerlink" title="下面的代码片段为函数式接口提供了一些指导："></a>下面的代码片段为函数式接口提供了一些指导：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>; &#125;</span><br><span class="line"><span class="comment">// Not functional because equals is already an implicit member (Object class)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Functional because Comparator has only one abstract non-Object method</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Not functional because method Object.clone is not public</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Functional: two methods, but they have the same signature</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function">Iterable <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function">Iterable&lt;String&gt; <span class="title">m</span><span class="params">(Iterable arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Functional: Y.m is a subsignature &amp; return-type-substitutable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;Integer&gt; arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Not functional: No method has a subsignature of all abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable&lt;String&gt; arg, Class c)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(Iterable arg, Class&lt;?&gt; c)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Not functional: No method has a subsignature of all abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">X</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">m</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Y</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span>, <span class="title">Y</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Compiler error: no method is return type substitutable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(T arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bar</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(T arg)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooBar</span>&lt;<span class="title">X</span>, <span class="title">Y</span>&gt; <span class="keyword">extends</span> <span class="title">Foo</span>&lt;<span class="title">X</span>&gt;, <span class="title">Bar</span>&lt;<span class="title">Y</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Compiler error: different signatures, same erasure</span></span><br></pre></td></tr></table></figure><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>由于在函数式接口中只有一个抽象函数，因此在将该lambda表达式应用于该方法时不会出现混淆。 Lambda表达式的语法是 <strong>(argument) -&gt; (body)</strong>。现在来看看如何使用lambda表达式写上面的匿名Runnable:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"My Runnable"</span>);</span><br></pre></td></tr></table></figure><p>让我们试着了解上面的lambda表达式中发生了什么。</p><ul><li>Runnable是一个函数式接口，这就是为什么我们可以使用lambda表达式来创建它的实例。</li><li>由于 run() 方法没有参数，我们的lambda表达式也没有参数。</li><li>就像if-else块一样，我们可以避免大括号({})，因为我们在方法体中只有单个语句。对于多个语句，我们必须像使用其他方法一样使用花括号。</li></ul><h2 id="为什么我们需要Lambda表达式"><a href="#为什么我们需要Lambda表达式" class="headerlink" title="为什么我们需要Lambda表达式"></a>为什么我们需要Lambda表达式</h2><h4 id="1、减少代码行数"><a href="#1、减少代码行数" class="headerlink" title="1、减少代码行数"></a>1、减少代码行数</h4><p>使用lambda表达式的一个明显优势是代码量减少了，我们已经看到，我们可以轻松地使用lambda表达式而不是使用匿名类来创建函数接口的实例。</p><h4 id="2、顺序和并行执行支持"><a href="#2、顺序和并行执行支持" class="headerlink" title="2、顺序和并行执行支持"></a>2、顺序和并行执行支持</h4><p>使用lambda表达式的另一个好处是我们可以从Stream API顺序和并行操作支持中受益。</p><p>为了解释这一点，我们举一个简单的例子，我们需要编写一个方法来测试一个数字是否是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Traditional approach</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(number &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;number; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(number % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题在于它本质上是顺序的，如果数字非常大，那么它将花费大量时间。代码的另一个问题是有太多的退出点使其可读性差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Declarative approach</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> number &gt; <span class="number">1</span></span><br><span class="line">&amp;&amp; IntStream.range(<span class="number">2</span>, number).noneMatch(</span><br><span class="line">index -&gt; number % index == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了提高可读性，我们也可以编写如下的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">IntPredicate isDivisible = index -&gt; number % index == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> number &gt; <span class="number">1</span></span><br><span class="line">&amp;&amp; IntStream.range(<span class="number">2</span>, number).noneMatch(</span><br><span class="line">isDivisible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、将行为传递给方法"><a href="#3、将行为传递给方法" class="headerlink" title="3、将行为传递给方法"></a>3、将行为传递给方法</h4><p>我们来看看如何使用lambda表达式来传递一个方法的行为。假设我们必须编写一个方法来对列表中的数字求和，如果它们符合给定的条件。我们可以使用Predicate并编写如下的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumWithCondition</span><span class="params">(List&lt;Integer&gt; numbers, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.parallelStream()</span><br><span class="line">    .filter(predicate)</span><br><span class="line">    .mapToInt(i -&gt; i)</span><br><span class="line">    .sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum of all numbers</span></span><br><span class="line">sumWithCondition(numbers, n -&gt; <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">//sum of all even numbers</span></span><br><span class="line">sumWithCondition(numbers, i -&gt; i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment">//sum of all numbers greater than 5</span></span><br><span class="line">sumWithCondition(numbers, i -&gt; i&gt;<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="4、使用惰性求值效率更高"><a href="#4、使用惰性求值效率更高" class="headerlink" title="4、使用惰性求值效率更高"></a>4、使用惰性求值效率更高</h4><p>使用lambda表达式的另一个优点是惰性求值(lazy evaluation)。假设我们需要编写一个方法来找出3到11范围内的最大奇数并返回它的平方。</p><p>通常我们会为此方法编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSquareOfMaxOdd</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">3</span> &amp;&amp; i &lt; <span class="number">11</span> &amp;&amp; i &gt; max) &#123;</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序总是按顺序运行，但我们可以使用Stream API来实现这一点，并获得Laziness-seeking的好处。我们来看看如何使用Stream API和lambda表达式以函数式编程方式重写此代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSquareOfMaxOdd</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numbers.stream()</span><br><span class="line">.filter(NumberTest::isOdd)      <span class="comment">//Predicate is functional interface and</span></span><br><span class="line">.filter(NumberTest::isGreaterThan3)<span class="comment">// we are using lambdas to initialize it</span></span><br><span class="line">.filter(NumberTest::isLessThan11)<span class="comment">// rather than anonymous inner classes</span></span><br><span class="line">.max(Comparator.naturalOrder())</span><br><span class="line">.map(i -&gt; i * i)</span><br><span class="line">.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGreaterThan3</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLessThan11</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; <span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象并不坏，但它给程序带来了很多冗长的内容。例如，假设我们要创建一个Runnable的实例。通常我们使用下面的匿名类来完成它：&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="Java 8" scheme="http://www.lovexue.xyz/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性之接口的默认方法和静态方法</title>
    <link href="http://www.lovexue.xyz/java/6376aac3/"/>
    <id>http://www.lovexue.xyz/java/6376aac3/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-08T03:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8接口新特性包括接口中的静态方法和默认方法。在Java 8之前，我们只能在接口中使用方法声明。但是从Java 8开始，我们可以在接口中使用默认方法和静态方法。</p><a id="more"></a><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>为了在java接口中创建一个默认方法，我们需要在方法签名中使用“<strong>default</strong>”关键字。例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I1 logging::"</span>+str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 log(String str) 是<code>Interface1</code>中的默认方法。现在当一个类实现<code>Interface1</code>时，并不强制为接口的默认方法提供实现。这个特性将帮助我们扩展接口和其他方法，我们所需要的只是提供一个默认实现。</p><p>另一个接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I2 logging::"</span>+str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们知道Java不允许我们继承多个类，因为它会导致“钻石问题”，因为编译器无法决定使用哪个超类方法。使用默认方法，”钻石问题”也会出现在接口上。因为如果一个类同时实现了<code>Interface1</code>和<code>Interface2</code>并且没有实现通用的默认方法，编译器无法决定选择哪一个。</strong>(备注：<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">The diamond problem</a>)</p><p>实现多个接口是Java不可或缺的组成部分，可以在核心Java类以及大多数企业应用程序和框架中找到它。所以为了确保这个问题不会发生在接口中，必须为通用的接口默认方法提供实现。因此，如果一个类正在实现上述两个接口，它将不得不为 log() 方法提供实现，否则编译器将抛出编译时错误。</p><p>一个同时实现<code>Interface1</code>和<code>Interface2</code>的简单类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyClass logging::"</span>+str);</span><br><span class="line">Interface1.print(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有关java接口默认方法的重点："><a href="#有关java接口默认方法的重点：" class="headerlink" title="有关java接口默认方法的重点："></a>有关java接口默认方法的重点：</h3><ul><li>Java 8接口的默认方法将帮助我们扩展接口，而不用担心会破坏实现类。</li><li>Java 8接口默认方法弥合了接口和抽象类之间的差异。</li><li>Java 8接口的默认方法将帮助我们避免utility类，比如所有的Collections类方法都可以在接口本身中提供。</li><li>Java接口的默认方法将帮助我们去除基础实现类，我们可以提供默认的实现，实现类可以选择重写哪一个。</li><li>在接口中引入默认方法的主要原因之一是增强Java 8中的Collections API以支持lambda表达式。</li><li>如果层次结构中的任何类具有相同签名的方法，则默认方法变得不相关。默认方法不能从<code>java.lang.Object</code>中覆盖方法。推理非常简单，这是因为Object是所有java类的基类。所以即使我们把Object类的方法定义为接口中的默认方法，也是无用的，因为总是使用Object类的方法。这就是为什么要避免混淆，我们不能有覆盖Object类方法的默认方法。</li><li>Java接口默认方法也被称为Defender方法或虚拟扩展方法。</li></ul><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>接口静态方法和默认方法类似，除了我们不能在实现类中override它们。这个特性有助于我们避免在实现类中由于不好的实现导致的不当结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isNull(str))</span><br><span class="line">System.out.println(<span class="string">"MyData Print::"</span> + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface Null Check"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str == <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="string">""</span>.equals(str) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看一个实现类，该类具有 isNull() 方法，但实现效果较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataImpl</span> <span class="keyword">implements</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Impl Null Check"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str == <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">MyDataImpl obj = <span class="keyword">new</span> MyDataImpl();</span><br><span class="line">obj.print(<span class="string">""</span>);</span><br><span class="line">obj.isNull(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 isNull(String str) 是一种简单的类方法，它不会覆盖接口方法。例如，如果我们将<code>@Override</code>注释添加到 isNull() 方法，则会导致编译器错误。</p><p>现在，当我们运行应用程序时，我们得到以下输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Interface Null Check</span><br><span class="line">Impl Null Check</span><br></pre></td></tr></table></figure><p>如果我们将接口方法从静态变为默认，我们将得到以下输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Impl Null Check</span><br><span class="line">MyData Print::</span><br><span class="line">Impl Null Check</span><br></pre></td></tr></table></figure><p>Java接口静态方法仅对接口方法可见，如果我们从 MyDataImpl 类中移除 isNull() 方法，我们将无法将其用于 MyDataImpl 对象。像其他静态方法一样，我们可以使用类名调用接口静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = MyData.isNull(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><h3 id="有关java接口静态方法的重点："><a href="#有关java接口静态方法的重点：" class="headerlink" title="有关java接口静态方法的重点："></a>有关java接口静态方法的重点：</h3><ul><li>Java接口的静态方法是接口的一部分，我们不能用它来实现类对象。</li><li>Java接口静态方法适用于提供utility方法，例如空检查，集合排序等。</li><li>Java接口静态方法通过不允许实现类override它们来帮助我们提供安全性。</li><li>我们不能为Object类方法定义接口静态方法，因为“这个静态方法不能从Object隐藏实例方法”，我们会得到编译器错误。这是因为它在java中是不允许的，因为Object是所有类的基类，我们不能有一个类级静态方法和另一个具有相同签名的实例方法。</li><li>我们可以使用java接口的静态方法来移除Collections等utility类，并将它的所有静态方法移到相应的接口中，这很容易找到和使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8接口新特性包括接口中的静态方法和默认方法。在Java 8之前，我们只能在接口中使用方法声明。但是从Java 8开始，我们可以在接口中使用默认方法和静态方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="Java 8" scheme="http://www.lovexue.xyz/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>聊聊JVM的年轻代</title>
    <link href="http://www.lovexue.xyz/java/24b8c8d9/"/>
    <id>http://www.lovexue.xyz/java/24b8c8d9/</id>
    <published>2018-02-09T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ifeve.com/jvm-yong-generation/" target="_blank" rel="noopener">本文章来源于并发编程网</a></p><p>堆内存模型大致如下：</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap_memory_model.jpg?raw=true" width="50%" height="50%" align="center"></p><a id="more"></a><h2 id="1-为什么会有年轻代"><a href="#1-为什么会有年轻代" class="headerlink" title="1. 为什么会有年轻代"></a>1. 为什么会有年轻代</h2><p>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><h2 id="2-年轻代中的GC"><a href="#2-年轻代中的GC" class="headerlink" title="2. 年轻代中的GC"></a>2. 年轻代中的GC</h2><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为 <strong>8:1:1</strong> ( 设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了复制算法的缺点 )。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理,直接分配到老年代),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在<strong>年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p><strong>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</strong></p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/young_generation.jpg?raw=true" width="50%" height="50%" align="center"></p><h2 id="3-一个对象的这一辈子"><a href="#3-一个对象的这一辈子" class="headerlink" title="3. 一个对象的这一辈子"></a>3. 一个对象的这一辈子</h2><p>我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p><h2 id="4-有关年轻代的JVM参数"><a href="#4-有关年轻代的JVM参数" class="headerlink" title="4. 有关年轻代的JVM参数"></a>4. 有关年轻代的JVM参数</h2><ul><li>-XX:NewSize和-XX:MaxNewSize</li></ul><p>用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p><ul><li>-XX:SurvivorRatio</li></ul><p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p><ul><li>-XX:+PrintTenuringDistribution</li></ul><p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p><ul><li>-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</li></ul><p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://ifeve.com/jvm-yong-generation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文章来源于并发编程网&lt;/a&gt;&lt;/p&gt;&lt;p&gt;堆内存模型大致如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap_memory_model.jpg?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lovexue.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://www.lovexue.xyz/java/91e798bc/"/>
    <id>http://www.lovexue.xyz/java/91e798bc/</id>
    <published>2018-02-08T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。<br><a id="more"></a></p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p><p><strong>Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了该被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量</strong>，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下：</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/JMM.jpg?raw=true" width="70%" height="70%" align="center"></p><p>这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分数据。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p><h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)。</p><ul><li><strong>lock</strong>(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><strong>unlock</strong>(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read</strong>(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li><strong>load</strong>(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use</strong>(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign</strong>(赋值)：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store</strong>(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><strong>write</strong>(写入)：作用于工作内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两个特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。<strong>虽然volatile变量在各个线程中是一致的，但是Java里面的运算并非原子操作，所以volatile变量的运算在并发下不能保证安全性。</strong></p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>使用volatile变量的第二个语义是<strong>禁止指令重排序优化</strong>。</p><h3 id="选用volatile的意义"><a href="#选用volatile的意义" class="headerlink" title="选用volatile的意义"></a>选用volatile的意义</h3><p>大多数场景下volatile的总开销要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</p><h2 id="对long和double型变量的特殊规则"><a href="#对long和double型变量的特殊规则" class="headerlink" title="对long和double型变量的特殊规则"></a>对long和double型变量的特殊规则</h2><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据结构(long和double)，在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即<strong>允许虚拟机实现选择可以不保证64位数据结构的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子协定</strong>。</p><h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><p><strong>原子性</strong>：</p><p><strong>可见性</strong>：</p><p><strong>有序性</strong>：</p><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p><strong>程序次序规则</strong>：</p><p><strong>管程锁定规则</strong>：</p><p><strong>volatile变量规则</strong>：</p><p><strong>线程启动规则</strong>：</p><p><strong>线程终止规则</strong>：</p><p><strong>线程中断规则</strong>：</p><p><strong>对象终极规则</strong>：</p><p><strong>传递性</strong>：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lovexue.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="http://www.lovexue.xyz/java/ba66848b/"/>
    <id>http://www.lovexue.xyz/java/ba66848b/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java运行时区域中，程序计数器、虚拟机栈、本地方法栈3个区域随线程的而生，随线程而灭，因此这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要多考虑回收的问题，因此方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配都是动态的，垃圾收集器所关注的是这部分内存。<br><a id="more"></a></p><h2 id="1、判断对象是否“存活”"><a href="#1、判断对象是否“存活”" class="headerlink" title="1、判断对象是否“存活”"></a>1、判断对象是否“存活”</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>引用计数法的实现简单，判定效率也高，但是主流的Java虚拟机里面没有选用其来管理内存，最主要原因是<strong>它很难解决对象之间相互循环引用的问题。</strong></p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索。搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时(从图论来说，从GC Roots到这个对象不可达)，则证明此对象是不可用的。</p><h4 id="在Java语言中，可作为GC-Roots的对象包括下面几种："><a href="#在Java语言中，可作为GC-Roots的对象包括下面几种：" class="headerlink" title="在Java语言中，可作为GC Roots的对象包括下面几种："></a>在Java语言中，可作为GC Roots的对象包括下面几种：</h4><ul><li><strong>虚拟机栈(栈帧中的本地变量表)中引用的对象。</strong></li><li><strong>方法区中类静态属性引用的对象。</strong></li><li><strong>方法区中常量引用的对象。</strong></li><li><strong>本地方法栈中JNI(Native方法)引用的对象。</strong></li></ul><h3 id="1-3-四种引用类型"><a href="#1-3-四种引用类型" class="headerlink" title="1.3 四种引用类型"></a>1.3 四种引用类型</h3><p>引入分为强引用、软引用、弱引用、虚引用4种。</p><ul><li><strong>强引用(Strong Reference)</strong></li></ul><p><code>StringBuilder builder = new StringBuilder();</code></p><p>强引用是默认引用类型，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><ul><li><strong>弱引用(Weak Reference)</strong></li></ul><p><code>WeakReference&lt;StringBuilder&gt; weakBuilder = new WeakReference&lt;StringBuilder&gt;(builder);</code></p><p>弱引用不是默认引用类型，如果需要使用弱引用，则要明确使用<code>WeakReference</code>类。弱引用用来描述非必需的对象。当内存中的对象只被弱引用时，它将可以被垃圾回收。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><ul><li><strong>软引用(Soft Reference)</strong></li></ul><p><code>SoftReference&lt;StringBuilder&gt; softBuilder = new SoftReference&lt;StringBuilder&gt;(builder);</code></p><p>软引用不是默认引用类型，如果需要使用软引用，则要明确使用<code>SoftReference</code>类。软引用用来描述一些还有用但是非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><ul><li><strong>虚引用(Phantom Reference)</strong></li></ul><p><code>PhantomReference&lt;StringBuilder&gt; phantomBuilder = new PhantomReference&lt;StringBuilder&gt;(builder);</code></p><p>虚引用不是默认引用类型，如果需要使用虚引用，则要明确使用<code>PhantomReference</code>类。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象呗收集器回收时收到一个系统通知。</p><h3 id="1-4-两次标记过程"><a href="#1-4-两次标记过程" class="headerlink" title="1.4 两次标记过程"></a>1.4 两次标记过程</h3><p><strong>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</strong> 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p><strong>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</strong> 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，<strong>稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象重新与引用链上任何一个对象建立关联，那么第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</strong></p><p><strong>注意：</strong> 任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h3><p><strong>方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。</strong> 例如常量池中的字面值常量没有任何对象引用它，并且也没有其他地方引用了这个字面量，则这个变量就是废弃变量。<strong>类需要满足3个条件才能算是无用的类：(1)该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；(2)加载该类的ClassLoader已经被回收；(3)该类对应的java.lang.Class对象没有在任何其他地方被引用，无法在任何地方通过反射访问该类的方法。</strong></p><p>虚拟机可以对废弃常量和无用的类进行回收，但并不是一定会回收，是否回收，由虚拟机提供的相关参数进行控制。</p><h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是<strong>效率问题</strong>，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的<strong>内存碎片</strong>。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg?raw=true" width="70%" height="70%" align="center"></p><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。<strong>实现简单，运行高效</strong>。只是这种算法的<strong>代价是将内存缩小为了原来的一半</strong>。现在的商业虚拟机都<strong>采用这种收集算法来回收新生代</strong>。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg?raw=true" width="70%" height="70%" align="center"></p><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低，所以一般不能用于老年代。根据老年代的特点，提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存</strong>。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg?raw=true" width="70%" height="70%" align="center"></p><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java运行时区域中，程序计数器、虚拟机栈、本地方法栈3个区域随线程的而生，随线程而灭，因此这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要多考虑回收的问题，因此方法结束或者线程结束时，内存自然就跟随着回收了。&lt;/p&gt;&lt;p&gt;而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配都是动态的，垃圾收集器所关注的是这部分内存。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lovexue.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot虚拟机对象探秘</title>
    <link href="http://www.lovexue.xyz/java/41b66951/"/>
    <id>http://www.lovexue.xyz/java/41b66951/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问全过程。<br><a id="more"></a></p><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h2><p>（1）<strong>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</strong></p><p>（2）<strong>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</strong></p><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”(Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间分配给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”(Free List)。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器是，通常采用空闲列表。</p><p>（3）除如何划分可用空间外，还有另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅<strong>修改一个指针所指向的位置，在并发情况下也并不是线程安全的</strong>，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<strong>解决这个问题有两种方案，一种是对分配空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并重新分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</strong></p><p>（4）<strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</strong></p><p>（5）<strong>接下来，虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<strong>这些信息存放在对象的对象头(Object Header)之中</strong>。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p>（6）在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——\&lt;init>方法还没有执行，所有的字段都还为零。所以，<strong>一般来说，执行new指令之后会接着执行\&lt;init>方法</strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><p><strong>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong>。</p><p><strong>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据</strong>，如哈希码(HashCode)、GC分待年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<strong>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中缺无法确定数据的大小。</p><p>接下来的<strong>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容</strong>。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p><p>第三部分<strong>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用</strong>。由于<strong>HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍</strong>，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h2><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。<strong>目前主流的访问方式有使用句柄和直接指针两种</strong>。</p><p>（1）如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与数据类型各自的具体地址信息。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png?raw=true" width="70%" height="70%" align="center"></p><p>（2）如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png?raw=true" width="75%" height="75%" align="center"></p><p>这两种对象访问方式各有优势，<strong>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改</strong>。</p><p><strong>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销</strong>，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。<strong>Sun HotSpot虚拟机是使用直接指针访问方式进行对象访问的</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问全过程。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lovexue.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>运行时数据区域</title>
    <link href="http://www.lovexue.xyz/java/20fd51d6/"/>
    <id>http://www.lovexue.xyz/java/20fd51d6/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机定义了程序执行期间使用的各种运行时数据区域。有的区域随着虚拟机的启动而存在并随着虚拟机的退出而销毁。有的数据区域是每个线程所独有的，随着线程的创建而创建并随着线程的退出而销毁。</p><p><img src="http://7xrgh9.com1.z0.glb.clouddn.com/16-10-16/6495951.jpg" alt=""><br><a id="more"></a></p><h2 id="1-1-程序计数器（program-counter-register）"><a href="#1-1-程序计数器（program-counter-register）" class="headerlink" title="1.1 程序计数器（program counter register）"></a>1.1 程序计数器（program counter register）</h2><p>程序计数器是一块较小的内存区域，它可以看作是当前线程所执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置，<strong>每个线程都需要有一个独立的程序计数器。位于线程私有内存。</strong></p><p><strong>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为Undefined。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p><h2 id="1-2-Java虚拟机栈-JVM-Stack"><a href="#1-2-Java虚拟机栈-JVM-Stack" class="headerlink" title="1.2 Java虚拟机栈(JVM Stack)"></a>1.2 Java虚拟机栈(JVM Stack)</h2><p><strong>每一个Java虚拟机线程都有一个私有的Java虚拟机栈，与线程同时创建。</strong></p><p><strong>Java虚拟机栈用于存储帧(frame)。每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当方法执行完成的时候，帧就被销毁了，无论方法是正常返回还是抛出未捕获的异常而中断。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。Java虚拟机栈的内存不需要是连续的</strong></p><p>经常所说的栈内存(Stack)指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong></p><h4 id="Java虚拟机栈存在以下两种异常状况："><a href="#Java虚拟机栈存在以下两种异常状况：" class="headerlink" title="Java虚拟机栈存在以下两种异常状况："></a>Java虚拟机栈存在以下两种异常状况：</h4><ul><li><strong>如果线程计算请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</strong></li><li><strong>如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展)，并且尝试扩展时无法申请到足够的内存或者没有足够的内存可用于为新线程创建初始Java虚拟机栈时，将抛出OutOfMemoryError异常。</strong></li></ul><h2 id="1-3-本地方法栈-Native-Method-Stack"><a href="#1-3-本地方法栈-Native-Method-Stack" class="headerlink" title="1.3 本地方法栈(Native Method Stack)"></a>1.3 本地方法栈(Native Method Stack)</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务</strong>。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="1-4-堆-Heap"><a href="#1-4-堆-Heap" class="headerlink" title="1.4 堆(Heap)"></a>1.4 堆(Heap)</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。<strong>Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong></p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。<strong>Java堆可以位于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有足够内存完成实例分配，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。</strong></p><h2 id="1-5-方法区-Method-Area"><a href="#1-5-方法区-Method-Area" class="headerlink" title="1.5 方法区(Method Area)"></a>1.5 方法区(Method Area)</h2><p><strong>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，例如运行时常量池、属性和方法的数据、方法和构造器的代码，以及类和接口初始化和实例初始化中使用的特殊方法。</strong></p><p>方法区不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。<strong>如果方法区的内存无法满足分配需求时，将抛出OutOfMemoryError异常。</strong></p><h2 id="1-6-运行时常量池-Run-Time-Constant-Pool"><a href="#1-6-运行时常量池-Run-Time-Constant-Pool" class="headerlink" title="1.6 运行时常量池(Run-Time Constant Pool)"></a>1.6 运行时常量池(Run-Time Constant Pool)</h2><p><strong>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</strong></p><p>每一个运行时常量池都从JVM方法区分配内存，类或接口的运行时常量池是在Java虚拟机创建类或接口时构建的。</p><p>运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的变量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p><strong>当创建类或接口时，如果无法从JVM方法区申请足够的内存来构造运行时常量池时，将抛出OutOfMemoryError异常。</strong></p><p><img src="http://ifeve.com/wp-content/uploads/2015/05/JUtH_20121024_RuntimeDataAreas_1_MemoryModel-1.png" alt=""></p><h2 id="重要总结："><a href="#重要总结：" class="headerlink" title="重要总结："></a>重要总结：</h2><p><strong>1. 永久代的变更到废除</strong></p><p><strong>变更(字符串常量池移到了堆)：</strong></p><p>在JDK6以及其前期的JDK版本中，永久代用于存储类信息和字符串常量池。</p><p>在JDK7中，永久代只用于存储类信息，字符串常量池在堆中存储。</p><p><strong>废弃(被Metaspace取代)：</strong></p><p>在JDK7以及其前期的JDK版本中，堆内存通常被分为两块区域，新生代(young<br>generation)和老年代(old generation)：显示如下图：</p><p>永久代(Permanent Generation for<br>VM Matedata)和代码缓存区(code cache area)属于非堆内存。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap.jpg?raw=true" width="50%" height="50%" align="center"></p><p>在JDK8中把存放元数据的永久代废弃，类信息存储到了在本地内存(native memory)<br>中叫Metaspace的区域，JDK8中JVM堆内存结构就变成了如下：</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/heap_2.jpg?raw=true" width="50%" height="50%" align="center"></p><p><strong>2. 方法区位置变化</strong></p><p>在JDK7以及之前的版本，方法区是永久代的一部分，在JDK8中方法区是Metaspace的一部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机定义了程序执行期间使用的各种运行时数据区域。有的区域随着虚拟机的启动而存在并随着虚拟机的退出而销毁。有的数据区域是每个线程所独有的，随着线程的创建而创建并随着线程的退出而销毁。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://7xrgh9.com1.z0.glb.clouddn.com/16-10-16/6495951.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lovexue.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hash冲突解决方案</title>
    <link href="http://www.lovexue.xyz/other/eebb0c54/"/>
    <id>http://www.lovexue.xyz/other/eebb0c54/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-03-15T12:27:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>开放地址法(open addressing)</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/hash_conflict.jpg?raw=true" alt=""><br><a id="more"></a><br><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/hash_conflict_2.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开放地址法(open addressing)&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/hash_conflict.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.lovexue.xyz/categories/other/"/>
    
    
      <category term="hash" scheme="http://www.lovexue.xyz/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Java String Constant Pool (Java字符串常量池)</title>
    <link href="http://www.lovexue.xyz/java/e52216a2/"/>
    <id>http://www.lovexue.xyz/java/e52216a2/</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你在Java中声明一个新的字符串时，在这个场景下有一些有趣的事情发生。</p><p>这是一个基本的字符串声明，我们创建了一个新的字符串变量<code>employee</code>并给它赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String employee = <span class="string">"Edgar Allen Poe"</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Java不仅会创建变量<code>employee</code>，而且还会为内存中的字面值“Edgar Allen Poe”分配空间。内存中的这个区域被称为<strong>字符串常量池</strong>。它就像程序的其他部分可用的字符串值池。</p><h2 id="重用字符串常量池中的值"><a href="#重用字符串常量池中的值" class="headerlink" title="重用字符串常量池中的值"></a>重用字符串常量池中的值</h2><p>现在，如果你创建了另一个变量，比如<code>employee2</code>，并且还给了它一个“Edgar Allen Poe”的值，那么Java只是重用了已经在池中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String employee2 = <span class="string">"Edgar Allen Poe"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/string_constant_pool_1.jpg?raw=true" width="335px" height="200px" align="center"></p><p>你会注意到字符串常量池位于内存的<strong>堆</strong>部分。</p><h2 id="创建一个新的字符串实例"><a href="#创建一个新的字符串实例" class="headerlink" title="创建一个新的字符串实例"></a>创建一个新的字符串实例</h2><p>如果你创建String类的新实例，则常量池的工作方式不同。让我们创建另一个变量<code>employee3</code>，并给它相同的字面值。但是，这次我们将创建一个String类的新实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String employee3 = <span class="keyword">new</span> String(<span class="string">"Edgar Allen Poe"</span>);</span><br></pre></td></tr></table></figure><p>当这个代码被处理时，Java将会有所不同。而不是再次使用相同的字面值，它会在内存中创建一个新的值。在这种情况下，它不会在字符串常量池中创建它，而是在内存堆中创建它。</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/string_constant_pool_2.jpg?raw=true" width="335px" height="201px" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你在Java中声明一个新的字符串时，在这个场景下有一些有趣的事情发生。&lt;/p&gt;&lt;p&gt;这是一个基本的字符串声明，我们创建了一个新的字符串变量&lt;code&gt;employee&lt;/code&gt;并给它赋值。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String employee = &lt;span class=&quot;string&quot;&gt;&quot;Edgar Allen Poe&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="Java基础" scheme="http://www.lovexue.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java -jar启动命令</title>
    <link href="http://www.lovexue.xyz/java/309440ba/"/>
    <id>http://www.lovexue.xyz/java/309440ba/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以下是java启动命令的语法说明"><a href="#以下是java启动命令的语法说明" class="headerlink" title="以下是java启动命令的语法说明:"></a>以下是java启动命令的语法说明:</h2><p>（<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">官方文档说明</a>）</p><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/java%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95.jpg?raw=true" width="350" height="350" align="center"></p><a id="more"></a><h2 id="以下是-options-的说明以及一些常用的"><a href="#以下是-options-的说明以及一些常用的" class="headerlink" title="以下是[options]的说明以及一些常用的:"></a>以下是[options]的说明以及一些常用的:</h2><p><strong>1、Standard Options</strong> 所有运行环境都支持</p><ul><li>-D 用于设置系统变量，由于spring boot会从系统属性读取属性，所以使用<code>@Value(&quot;myDir&quot;)</code>即可获取。</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-D%20option.jpg?raw=true" width="50%" height="50%" align="center"></p><ul><li>-jar 用于指定启动的jar文件，jar文件的manifest必须知道Main-Class</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-jar%20option.jpg?raw=true" width="150%" height="150%" align="center"></p><p><strong>2、Nonstandard Options</strong> 由Java HotSpot VMs默认提供</p><ul><li>-Xmn 设置新生代的大小</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-Xmn%20option.jpg?raw=true" width="30%" height="30%" align="center"></p><ul><li>-Xms 设置内存分配池的最小值，即初始值</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-Xms%20option.jpg?raw=true" align="center"></p><ul><li>-Xmx 设置内存分配池的最大值</li></ul><p><img src="https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/-Xmx%20option.jpg?raw=true" align="center"></p><p>对于服务器部署，-Xms和-Xmx通常设置为相同的值。</p><h2 id="以下是-arguments-说明："><a href="#以下是-arguments-说明：" class="headerlink" title="以下是[arguments]说明："></a>以下是[arguments]说明：</h2><p>语法为 <strong>–{name}={value}</strong></p><p>例如：<br><code>java -jar app.jar --name=&quot;Spring&quot;</code> 。由于spring boot会从command line argument读取属性，所以使用<code>@Value(&quot;name&quot;)</code>即可获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以下是java启动命令的语法说明&quot;&gt;&lt;a href=&quot;#以下是java启动命令的语法说明&quot; class=&quot;headerlink&quot; title=&quot;以下是java启动命令的语法说明:&quot;&gt;&lt;/a&gt;以下是java启动命令的语法说明:&lt;/h2&gt;&lt;p&gt;（&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档说明&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/Java-Notebook/blob/master/Java%20Basic/images/java%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95.jpg?raw=true&quot; width=&quot;350&quot; height=&quot;350&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="Java基础" scheme="http://www.lovexue.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Executor,ExecutorService和Executors间的不同</title>
    <link href="http://www.lovexue.xyz/java/8542269d/"/>
    <id>http://www.lovexue.xyz/java/8542269d/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-03-04T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yemengying.com/2017/03/17/difference-between-executor-executorService/" target="_blank" rel="noopener">文章摘录自博客</a></p><p><span style="color:#ff4500"><code>java.util.concurrent.Executor</code>, <code>java.util.concurrent.ExecutorService</code>, <code>java.util.concurrent.Executors</code></span>这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免<span style="color:#ff4500"><code>&quot;java.lang.OutOfMemoryError: unable to create new native thread&quot;</code></span>之类的错误。</p><p>在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：<code>FixedThreadPool</code>(包含固定数目的线程)，<code>CachedThreadPool</code>(可根据需要创建新的线程)等等。<br><a id="more"></a></p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor，ExecutorService，和 Executors 最主要的区别是 Executor 是一个抽象层面的核心接口(大致代码如下)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于<span style="color:#ff4500"><code>java.lang.Thread</code></span>类将任务和执行耦合在一起， Executor 将任务本身和执行任务分离，可以阅读 <a href="http://javarevisited.blogspot.sg/2016/12/difference-between-thread-and-executor.html" target="_blank" rel="noopener">difference between Thread and Executor</a> 来了解 Thread 和 Executor 间更多的不同。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>ExecutorService 接口 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。当调用<span style="color:#ff4500"><code>shutDown</code></span>方法时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。</p><p>Future 对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 Future 是否已经有了结果，如果任务已经执行完成，就可以通过 Future.get( ) 方法获得执行结果。需要注意的是，Future.get( ) 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。</p><p>通过 ExecutorService.submit( ) 方法返回的 Future 对象，还可以取消任务的执行。Future 提供了 <span style="color:#ff4500"><code>cancel()</code></span>方法用来取消执行 pending 中的任务。</p><p>ExecutorService 部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。</p><p>Executors 部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executor-vs-ExecutorService-vs-Executors"><a href="#Executor-vs-ExecutorService-vs-Executors" class="headerlink" title="Executor vs ExecutorService vs Executors"></a>Executor vs ExecutorService vs Executors</h2><p>正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解：</p><ul><li>Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口</li><li>Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 <span style="color:#ff4500"><code>execute()</code></span>方法用来接收一个<span style="color:#ff4500"><code>Runnable</code></span>接口的对象，而 ExecutorService 接口中的 <span style="color:#ff4500"><code>submit()</code></span>方法可以接受<span style="color:#ff4500"><code>Runnable</code></span>和<span style="color:#ff4500"><code>Callable</code></span>接口的对象。</li><li><p>Executor 和 ExecutorService 接口第三个区别是 Executor 中的 <span style="color:#ff4500"><code>execute()</code></span>方法不返回任何结果，而 ExecutorService 中的 <span style="color:#ff4500"><code>submit()</code></span>方法可以通过一个 Future 对象返回运算结果。</p></li><li><p>Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 <span style="color:#ff4500"><code>shutDown()</code></span>方法终止线程池。可以通过 <a href="http://www.amazon.com/dp/0321349601/?tag=javamysqlanta-20" target="_blank" rel="noopener">《Java Concurrency in Practice》</a> 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。</p></li><li><p>Executors 类提供工厂方法用来创建不同类型的线程池。比如: <span style="color:#ff4500"><code>newSingleThreadExecutor()</code></span>创建一个只有一个线程的线程池，<span style="color:#ff4500"><code>newFixedThreadPool(int numOfThreads)</code></span>来创建固定线程数的线程池，<span style="color:#ff4500"><code>newCachedThreadPool()</code></span>可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表列出了 Executor 和 ExecutorService 的区别：</p><table><thead><tr><th style="text-align:left">Executor</th><th style="text-align:left">ExecutorService</th></tr></thead><tbody><tr><td style="text-align:left">Executor 是 Java 线程池的核心接口，用来并发执行提交的任务</td><td style="text-align:left">ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法</td></tr><tr><td style="text-align:left">提供execute()方法用来提交任务</td><td style="text-align:left">提供submit()方法用来提交任务</td></tr><tr><td style="text-align:left">execute()方法无返回值</td><td style="text-align:left">submit()方法返回Future对象，可用来获取任务执行结果</td></tr><tr><td style="text-align:left">不能取消任务</td><td style="text-align:left">可以通过Future.cancel()取消pending中的任务</td></tr><tr><td style="text-align:left">没有提供和关闭线程池有关的方法</td><td style="text-align:left">提供了关闭线程池的方法</td></tr></tbody></table><h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>个人觉得，利用 Executors 类提供的工厂方法来创建一个线程池是很方便，但对于需要根据实际情况自定义线程池某些参数的场景，就不太适用了。</p><p>举个例子：<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：</p><ul><li>AbortPolicy: 直接抛异常</li><li>CallerRunsPolicy: 用调用者的线程来运行任务</li><li>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务</li><li>DiscardPolicy 直接将新任务丢弃</li></ul><p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p><p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p><p>当然，在使用 Spring 框架的项目中，也可以使用 Spring 提供的 ThreadPoolTaskExecutor 类来创建线程池。ThreadPoolTaskExecutor 与 ThreadPoolExecutor 类似，也提供了许多参数用来自定义线程池，比如：核心线程池大小，线程池最大数量，饱和策略，线程活动保持时间等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://yemengying.com/2017/03/17/difference-between-executor-executorService/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章摘录自博客&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color:#ff4500&quot;&gt;&lt;code&gt;java.util.concurrent.Executor&lt;/code&gt;, &lt;code&gt;java.util.concurrent.ExecutorService&lt;/code&gt;, &lt;code&gt;java.util.concurrent.Executors&lt;/code&gt;&lt;/span&gt;这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免&lt;span style=&quot;color:#ff4500&quot;&gt;&lt;code&gt;&amp;quot;java.lang.OutOfMemoryError: unable to create new native thread&amp;quot;&lt;/code&gt;&lt;/span&gt;之类的错误。&lt;/p&gt;&lt;p&gt;在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：&lt;code&gt;FixedThreadPool&lt;/code&gt;(包含固定数目的线程)，&lt;code&gt;CachedThreadPool&lt;/code&gt;(可根据需要创建新的线程)等等。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.lovexue.xyz/categories/java/"/>
    
    
      <category term="Java基础" scheme="http://www.lovexue.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
